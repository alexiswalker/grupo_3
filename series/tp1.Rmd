---
title:  | 
        Trabajo Práctico N° 1
subtitle: |
          Análisis de Series Temporales
      
          Maestría en Explotación de Datos y Gestión del Conocimiento
author: |
        Layla Scheli, Franco Lianza, Lucio Scalzo, Ignacio Mujica, Alexis Walker
date: |
      `r format(Sys.time(), '%d %B %Y')`


header-includes:
- \usepackage{titling}
- \usepackage{floatrow}
- \usepackage{lipsum}

- \renewcommand{\figurename}{Fig.}
- \renewcommand{\contentsname}{Índice}
- \renewcommand{\tablename}{Tabla}

- \pretitle{
      \begin{center}
      \thispagestyle{empty}
      \includegraphics[width=2in,height=2in]{logo.png}\LARGE\\
      \vskip 12em
  }
- \posttitle{\end{center}}

- \preauthor{
      \begin{center}
      \vskip 26em
  }
- \postauthor{\end{center}}
  
- \predate{\begin{center}}
- \postdate{
    \end{center}
    \vskip 4em
  }

output: 
  pdf_document
---
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\abstract
\lipsum[1]
\newpage

\thispagestyle{empty}
\setcounter{tocdepth}{4}
\tableofcontents
\newpage

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)

paquetes <- c("readr", "tidyverse", "showtext", "forecast", "gridExtra",
              "tseries", "tsibble", "kableExtra")

instalados <- paquetes %in% rownames(installed.packages())

if (any(instalados == FALSE)) {
  install.packages(paquetes[!instalados])
}

invisible(lapply(paquetes, library, character.only = TRUE))

theme_set(theme_bw())
```

```{r}
#TODO
showtext_auto()

plot_series <- function(ts, title, ylabel = "", subtitle = NA) {
  p_series <- autoplot(ts) +
    geom_line(color = "steelblue") +
    stat_smooth(method = "lm", col = "red3", formula = y ~ x, size = 0.4, se = FALSE) +
    scale_y_continuous(name = ylabel) +
    labs(x = "Tiempo")
  
  if (is.na(subtitle)) {
    p_series <- p_series + ggtitle(title)
  } else {
    p_series <- p_series + ggtitle(title, subtitle = subtitle)
  }
  
  p_acf <- ggAcf(ts, type = "correlation") +
    ggtitle("Autocorrelación") + 
    labs(y = "")
  
  p_pacf <- ggAcf(ts, type = "partial") +
    ggtitle("Autocorrelación Parcial") + 
    labs(y = "" )
  
  grid.arrange(p_series, arrangeGrob(p_acf, p_pacf, ncol=2))
}

incorrelation <- function(ts, type = c("Ljung-Box","Box-Pierce"), fitdf = 0){
  p_ljung_box = NULL
  s_ljung_box = NULL
  for(i in 0:(length(ts)/4)){
    p_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$p.value
    s_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$statistic
  }
  table = data.frame(lag = 1:(length(ts)/4),
                     pvalue = p_ljung_box,
                     estadístico = s_ljung_box)
  return(table)
}

test_incorrelation <- function(ts, title = "Pruebas de Incorrelacion") {
  i_box_pierce <- incorrelation(ts, "Box-Pierce")
  i_ljung_box <- incorrelation(ts, "Ljung-Box")
  
  test_incorrelation_data <- merge(i_box_pierce, i_ljung_box, by="lag", suffixes = c("",""))
  
  test_incorrelation_data %>%
      kable(booktabs = T, caption = title, digits = 3) %>%
      column_spec(2, color = ifelse(test_incorrelation_data[2] > 0.05, "blue", "black")) %>% 
      column_spec(4, color = ifelse(test_incorrelation_data[4] > 0.05, "blue", "black")) %>% 
      add_header_above(c(" " = 1, "Box-Pierce" = 2, "Ljung-Box" = 2)) %>%
      kable_styling(latex_options = c("striped", "hold_position"), full_width = F, font_size = 7)
}

aic_grid_search <- function(ts, p = 1, q = 1){
  require(forecast)
  expand.grid(0:p, 0:q) %>% 
    rename(p = Var1, q = Var2) %>%
    mutate(aic = map2_dbl(p, q, function(p, q){AIC(arima(ts, order = c(p,0,q), include.mean = F, method="ML"))}))
}

bic_grid_search <- function(ts, p = 1, q = 1){
  require(forecast)
  expand.grid(0:p, 0:q) %>% 
    rename(p = Var1, q = Var2) %>%
    mutate(bic = map2_dbl(p, q, function(p, q){BIC(arima(ts, order = c(p,0,q), include.mean = F, method="ML"))}))
}
```

<!-- datos -->

```{r}
raw_data <- read_csv(
  file = "https://docs.google.com/uc?id=16we_OjrEZxBUwaQKOh3QAoW5YwfcEg1E",
  col_types = cols(fecha = col_date(format = "%d/%m/%Y")))
```

```{r}
indice_precios_consumidor <- raw_data %>%
  select(fecha, indice_precios_consumidor_acumulada)

indice_salarios <- raw_data %>%
  select(fecha, indice_salarios_acumulada)

ts_indice_precios_consumidor <- indice_precios_consumidor$indice_precios_consumidor_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_indice_salarios <- indice_salarios$indice_salarios_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))
```

# Introducción

La inflación puede ser un fenómeno producido por múltiples causas. Uno de los supuestos que puede darle origen es el resultado de la distorsión del mercado debido a aumentos salariales. La percepción individual sugiere que los motivos, en la coyuntura actual, son otros: especulación, emisión, devaluación, exportaciones, monopolios formadores de precios, etc.

Analizar como evolucionan conjuntamente en el tiempo el **Índice de precios al consumidor** y el **Índice de salarios** puede brindar soporte a la sospecha planteada. Además, esta comparativa muestra cómo se comporta el poder adquisitivo de un empleado. Es posible determinar si se recompone conforme aumentan los precios, acompaña o se abre una brecha que da cuenta de su disminución. 

La información fue extraída de la página oficial del Instituto Nacional de Estadística y Censos - INDEC Argentina:

- [Índice de precios al consumidor](https://www.indec.gob.ar/ftp/cuadros/economia/sh_ipc_10_21.xls)
- [Índice de salarios](https://www.indec.gob.ar/ftp/cuadros/sociedad/variaciones_salarios_09_21.xls)

Y se considera la variación mensual acumulada estableciendo a Diciembre 2016 como el 100%.

```{r fig.cap="Inflación versus Salarios", fig.height=4, fig.width=10, fig.pos="H"}
ggplot(raw_data, aes(x = fecha)) +
  geom_line(aes(y = indice_precios_consumidor_acumulada), color = "red3") +
  geom_line(aes(y = indice_salarios_acumulada), color = "steelblue") +
  scale_y_continuous(
    name = "Índice de precio al consumidor",
    sec.axis = sec_axis(~., name = "Índice de salarios")) +
  theme(
    axis.title.y = element_text(color = "red3"),
    axis.title.y.right = element_text(color = "steelblue")
  ) +
  labs(x = "Tiempo") +
  ggtitle("Inflación versus Salarios")
```

Predecir el comportamiento de estos índices puede ser de utilidad para estimar el impacto de un nuevo rumbo en la gestión.

\newpage

# Marco Teórico

Ambas series temporales exhiben una marcada tendencia creciente que hace suponer una media también creciente en el tiempo, por lo que es probable que el proceso estocástico que la ha generado no sea estacionario en primer orden.

## Estacionariedad

A fin de mejorar la normalidad de los datos se analiza la tendencia y estacionalidad. La diferenciación es el instrumento que permite eliminar estos componentes para conseguir estacionariedad.

TODO: ver de agregar una referencia a URIEL o PENA.

### Índice de precios al consumidor

Se puede observar en la gráfica de autocorrelación (Fig. 2) como la serie no es estacionaria ya que el valor de la función no decae de manera exponencial. También se aprecia que no parece existir un componente estacional.

```{r fig.cap="Índice de precios al consumidor", fig.height=5, fig.width=10, fig.pos="H"}
plot_series(ts_indice_precios_consumidor, title = "Índice de precios al consumidor")
```

```{r}
indice_precios_consumidor_ndiffs <- ndiffs(ts_indice_precios_consumidor)
indice_precios_consumidor_nsdiffs <- nsdiffs(ts_indice_precios_consumidor)
```

Se estima el número de diferenciaciones regulares y estacionales que deberían llevarse a cabo para que la serie sea estacionaria.

- Número de diferenciaciones regulares: `r indice_precios_consumidor_ndiffs`
- Número de diferenciaciones estacionales: `r indice_precios_consumidor_nsdiffs`

Y se procede a su ejecución conforme el resultado sugerido.

```{r fig.cap="Índice de precio al consumidor y su tendencia", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_indice_precios_consumidor <- ts_indice_precios_consumidor %>%
  diff(1) %>% 
  diff(1)

plot_series(dif_ts_indice_precios_consumidor, 
            title = "Índice de precios al consumidor", 
            subtitle = "Diferenciado dos veces")
```    

Luego de presentar el resultado (Fig. 3) junto a un modelo lineal simple, se entiende que se ha conseguido estacionariedad en la media.

Se repite el análisis de autocorrelaciones (Fig. 3), ahora el resultado tiene el comportamiento de un camino aleatorio diferenciado. El lag numero 6 en la funcion de autocorrelacion es significativo, por lo que puede indicar que existe algun componente estacional.

Se formalizan las conclusiones realizando los tests de Box-Pierce y Ljung-Box.

```{r}
test_incorrelation(dif_ts_indice_precios_consumidor)
```

El test de Box-Pierce utiliza a $\sigma^2(\hat{\rho_j}(Y))\cong1/n$ como estimador de la varianza, lo que produce un sesgo al no rechazo de la hipotesis nula que los $\rho_1(Y)=\rho_2(Y)=...=\rho_j(Y)=0$. TODO: agregar referencia URIEL.


TODO: esto lo dejamos? deberiamos preguntar en el foro:
A partir del lag numero 6, los p-values del test de Ljung-Box son significativos. Se procede a diferenciar la serie una vez mas con lag=6.

```{r fig.cap="Índice de precio al consumidor y su tendencia diferenciados con lag=6", fig.height=5, fig.width=10, fig.pos="H"}
dif_6_ts_indice_precios_consumidor <- dif_ts_indice_precios_consumidor %>%
  diff(6)

plot_series(dif_6_ts_indice_precios_consumidor, 
            title = "Índice de precios al consumidor diferenciado 2 veces", 
            subtitle = "Diferenciado dos veces")
```

```{r}
test_incorrelation(dif_6_ts_indice_precios_consumidor)
```

### Índice de Salarios

Se puede observar en la gráfica de autocorrelación (Fig. 5) que la serie de Índices de Salarios tiene el mismo comportamiento que la anterior.

```{r fig.cap="Índice de Salarios", fig.height=5, fig.width=10, fig.pos="H"}
plot_series(ts_indice_salarios, title = "Índice de Salarios")
```


```{r}
indice_salarios_ndiffs <- ndiffs(ts_indice_salarios)
indice_salarios_nsdiffs <- nsdiffs(ts_indice_salarios)
```

Se estima el número de diferenciaciones regulares y estacionales que deberían llevarse a cabo para que la serie sea estacionaria.

- Número de diferenciaciones regulares: `r indice_salarios_ndiffs`
- Número de diferenciaciones estacionales: `r indice_salarios_nsdiffs`

Y se procese a su ejecución conforme el resultado sugerido.

```{r fig.cap="Índice de Salarios y su tendencia", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_indice_salarios <- ts_indice_salarios %>% diff(1)

plot_series(dif_ts_indice_salarios, 
            title = "Índice de Salarios",
            subtitle = "Diferenciado")
```

A pesar de la sugerencia del número de diferenciaciones, no parece eliminarse la tendencia (Fig. 6). Por lo que se repite el procedimiento una vez más.

```{r fig.cap="Índice de Salarios y su tendencia", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_indice_salarios <- ts_indice_salarios %>% diff(1) %>% diff(1)

plot_series(dif_ts_indice_salarios, 
            title = "Índice de Salarios",
            subtitle = "Diferenciado dos veces")
```

El resultado (Fig. 7) junto a un modelo lineal simple, muestra la estacionariedad en la media.

Se repite el análisis de autocorrelaciones (Fig. 8), ahora el resultado tiene el comportamiento de un camino aleatorio diferenciado.

```{r warning=FALSE}
test_incorrelation(dif_ts_indice_salarios)
```

(Tabla 2) TODO: <que conclusión sacar?>

\newpage

## Modelos

Una vez transformada la información para satisfacer los supuestos de los modelos a utilizar, se estiman los parámetros que mejoran su comportamiento.

### Índice de precios al consumidor

#### Estimación

Se calculan, para la serie temporal, distintos órdenes de parámetros del modelo ARMA y se comparan AIC y BIC como criterios de información.

```{r warning=FALSE, fig.cap="Criterios de Información", fig.height=3.5, fig.width=8, fig.pos="H"}
aic_data_indice_precios_consumidor <- aic_grid_search(dif_ts_indice_precios_consumidor, 3, 7)

aic_plot <- ggplot(aic_data_indice_precios_consumidor, aes(p, q)) +
  geom_tile(aes(fill = aic)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = aic, label = round(aic, 2))) +
  ggtitle("AIC")

bic_data_indice_precios_consumidor <- bic_grid_search(dif_ts_indice_precios_consumidor, 3, 7)

bic_plot <- ggplot(bic_data_indice_precios_consumidor, aes(p, q)) +
  geom_tile(aes(fill = bic)) + 
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = bic, label = round(bic, 2)))  +
  ggtitle("BIC")

grid.arrange(aic_plot, bic_plot, ncol=2)
```

En ambos casos, el modelo sugerido es ARMA(1, 1) (Fig. 9).

```{r}
train_data_ipc <- window(dif_ts_indice_precios_consumidor, end= c(2021, 4))

test_data_ipc <- window(dif_ts_indice_precios_consumidor, start= c(2021, 05))
```

#### Métrica de performance

Se resumen las métricas del modelo propuesto (Tabla 3).

```{r}
model_aic_bic_ipc <- arima(train_data_ipc, order = c(1,0,1), include.mean = F)

my_forecast_ipc <- forecast(model_aic_bic_ipc, h = length(test_data_ipc))

accuracy_aic_bic_ipc <- accuracy(test_data_ipc, my_forecast_ipc$mean)
```

```{r}
metrics_aic_bic_ipc<- accuracy_aic_bic_ipc %>%
  as_tibble() %>%
  add_column(Modelo = "arima(order = c(1, 0, 1))", .before = "ME")

metrics_aic_bic_ipc %>%
  kable(booktabs = T, caption = "Métricas", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


#### Comparación

Existen herramientas para determinar automáticamente un modelo que mejor ajuste. Se aprovecha esta posibilidad y se compara con el modelo antes elegido.

```{r}
auto_model_ipc <- auto.arima(train_data_ipc)
my_forecast_auto_ipc <- forecast(auto_model_ipc, h = length(test_data_ipc))
acurracy_auto_ipc <- accuracy(test_data_ipc, my_forecast_auto_ipc$mean)
```

```{r}
metrics_auto_ipc <- acurracy_auto_ipc %>%
  as_tibble() %>%
  add_column(Modelo = "auto: ARIMA(1,0,1)", .before = "ME")

rbind(metrics_aic_bic_ipc, metrics_auto_ipc) %>%
  kable(booktabs = T, caption = "Métricas", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Ambos análisis conducen al mismo resultado (Tabla 4).

#### Análisis de Diagnóstico

Visualmente no se evidencia tendencia, por lo que se asumir que la media y varianza son constantes. El histograma (Fig. 10) muestra con comportamiento normal con media cero; lo que se corrobora a partir del test de Shapiro-Wilk con un p-value `r shapiro.test(residuals(auto_model_ipc))[["p.value"]]`. El gráfico de autocorrelación se asemeja al del ruido blanco: p-value `r Box.test(residuals(auto_model_ipc), lag = 1, type = "Ljung-Box", fitdf = 0)$p.value` del test Ljung-Box con lag igual a 1.

```{r fig.cap="Residuos", fig.height=3.5, fig.width=10, warning=FALSE, fig.pos="H"}
ggtsdisplay(residuals(auto_model_ipc), lag.max = 24, main = 'Residuos', plot.type = "histogram")
```

#### Pronóstico

Se comparan los modelos analizados en una prueba de pronóstico (Fig. 11).

```{r fig.cap="Pronóstico", fig.height=2.3, fig.width=10}

colors <- c("train" = "blue", "test" = "red", "forecast" = "orange", "auto" = "gray")
ggplot() +
  geom_line(data = as_tsibble(train_data_ipc), aes(x = index, y = value, color = "train")) +
  geom_line(data = as_tsibble(test_data_ipc), aes(x = index, y = value, color = "test")) +
  geom_line(data = as_tsibble(forecast(model_aic_bic_ipc, h = 3)$mean), aes(x = index, y = value, color = "forecast")) +
  geom_line(data = as_tsibble(forecast(auto_model_ipc, h = 3)$mean), aes(x = index, y = value, color = "auto")) +
  scale_color_manual(name = "", values = colors) +
  labs(x = "Tiempo") +
  ggtitle("Pronóstico")

```

\newpage

### Índice de Salarios

#### Estimación

Se calculan, para la serie temporal, distintos órdenes de parámetros del modelo ARMA y se comparan AIC y BIC como criterios de información (Fig. 12).

```{r warning=FALSE, fig.cap="Criterios de Información", fig.height=3.5, fig.width=10, fig.pos="H"}

aic_data_is <- aic_grid_search(dif_ts_indice_salarios, 3, 7)

aic_plot_is <- ggplot(aic_data_is, aes(p, q)) +
  geom_tile(aes(fill = aic)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = aic, label = round(aic, 2))) +
  ggtitle("AIC")

bic_data_is <- bic_grid_search(dif_ts_indice_salarios, 3, 7)

bic_plot_is <- ggplot(bic_data_is, aes(p, q)) + 
  geom_tile(aes(fill = bic)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = bic, label = round(bic, 2)))  +
  ggtitle("BIC")

grid.arrange(aic_plot_is, bic_plot_is, ncol=2)
```

En este caso:

- AIC sugiere un p igual 1 y un q = 3.
- BIC sugiere un p igual a q igual a 1.

```{r}
train_data_is <- window(dif_ts_indice_salarios, end= c(2021, 04))

test_data_is <- window(dif_ts_indice_salarios, start= c(2021, 05))
```

#### Métrica de performance

Se resumen las métricas para ambos modelos (Tabla 5 y 6).

```{r}
model_aic_is <- arima(train_data_is, order = c(1,0,3), include.mean = F)
my_forecast_aic_is <- forecast(model_aic_is, h = length(test_data_is))
accuracy_aic_is <- accuracy(test_data_is, my_forecast_aic_is$mean)

model_bic_is <- arima(train_data_is, order = c(1,0,1), include.mean = F)
my_forecast_bic_is <- forecast(model_bic_is, h = length(test_data_is))
accuracy_bic_is <- accuracy(test_data_is, my_forecast_bic_is$mean)  
```

```{r}
metrics_aic_is <- accuracy_aic_is %>%
  as_tibble() %>%
  add_column(Modelo = "arima(order = c(1, 0, 3))", .before = "ME")

metrics_aic_is %>%
  kable(booktabs = T, caption = "Mejor modelos según AIC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

```{r}
metrics_bic_is <- accuracy_bic_is %>%
  as_tibble() %>%
  add_column(Modelo = "arima(order = c(1, 0, 1))", .before = "ME")

metrics_bic_is %>%
  kable(booktabs = T, caption = "Mejor modelos según BIC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

#### Comparación

Nuevamente se aprovecha la posibilidad de determinar automaticamente un buen modelo y se suma el resultado a lo ya planteado (Tabla 7).

```{r}
auto_model_is <- auto.arima(train_data_is)
my_forecast_auto_is <- forecast(auto_model_is, h = length(test_data_is))
accuracy_auto_is <- accuracy(test_data_is, my_forecast_auto_is$mean)  
```

```{r}
metrics_auto_is <- accuracy_auto_is %>%
  as_tibble() %>%
  add_column(Modelo = "auto: ARIMA(0,0,0)(1,0,0)[12]", .before = "ME")

rbind(metrics_aic_is, metrics_bic_is, metrics_auto_is) %>%
  kable(booktabs = T, caption = "Métricas", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

El mejor es ?? 

#### Análisis de Diagnóstico

Visualmente no se evidencia tendencia, por lo que se asumir que la media y varianza son constantes. El histograma (Fig. 13) muestra con comportamiento normal con media cero; lo que se corrobora a partir del test de Shapiro-Wilk con un p-value `r shapiro.test(residuals(auto_model_is))[["p.value"]]`. El gráfico de autocorrelación se asemeja al del ruido blanco: p-value `r Box.test(residuals(auto_model_is), lag = 1, type = "Ljung-Box", fitdf = 0)$p.value` del test Ljung-Box con lag igual a 1.

```{r fig.cap="Residuos", fig.height=3.5, fig.width=10, warning=FALSE}
residuals_is <- resid(auto_model_is)
checkresiduals(residuals_is)
```

#### Pronóstico

Se comparan los modelos analizados en una prueba de pronóstico (Fig. 11).

```{r fig.cap="Pronóstico", fig.height=2.3, fig.width=10}

colors <- c("train" = "blue", "test" = "red", "aic" = "orange", "bic" = "gray", "auto" = "black")
ggplot() +
  geom_line(data = as_tsibble(train_data_is), aes(x = index, y = value, color = "train")) +
  geom_line(data = as_tsibble(test_data_is), aes(x = index, y = value, color = "test")) +
  geom_line(data = as_tsibble(forecast(model_aic_is, h = 3)$mean), aes(x = index, y = value, color = "aic")) +
  geom_line(data = as_tsibble(forecast(model_bic_is, h = 3)$mean), aes(x = index, y = value, color = "bic")) +
  geom_line(data = as_tsibble(forecast(auto_model_is, h = 3)$mean), aes(x = index, y = value, color = "auto")) +
  scale_color_manual(name = "", values = colors) +
  labs(x = "Tiempo") +
  ggtitle("Pronóstico")
```

\newpage

# Análisis de Resultados
\lipsum[1]
\newpage

# Conclusiones
\lipsum[1]
\newpage

# Referencias bibliográficas
\lipsum[1]
\newpage

# Apéndices

## Decomposición

### Índice de precios al consumidor

```{r fig.cap="Funciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
decompose_plot <- dif_ts_indice_precios_consumidor %>%
  decompose(type = "additive") %>%
  autoplot(ts.colour = "steelblue")
decompose_plot + xlab("Tiempo") + ggtitle("Descoposición aditiva")
```

### Índice de Salarios

```{r fig.cap="Funciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
decompose_plot <- dif_ts_indice_salarios %>%
  decompose(type = "additive") %>%
  autoplot(ts.colour = "steelblue")
decompose_plot + xlab("Tiempo") + ggtitle("Descoposición aditiva")
```
