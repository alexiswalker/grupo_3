---
title:  | 
        Trabajo Práctico N° 1
subtitle: |
          Análisis de Series Temporales
      
          Maestría en Explotación de Datos y Gestión del Conocimiento
author: |
        Layla Scheli, Franco Lianza, Lucio Scalzo, Ignacio Mujica, Alexis Walker
date: |
      `r format(Sys.time(), '%d %B %Y')`


header-includes:
- \usepackage{titling}
- \usepackage{floatrow}
- \usepackage{lipsum}

- \renewcommand{\figurename}{Fig.}
- \renewcommand{\contentsname}{Índice}
- \renewcommand{\tablename}{Tabla}

- \pretitle{
      \begin{center}
      \thispagestyle{empty}
      \includegraphics[width=2in,height=2in]{logo.png}\LARGE\\
      \vskip 12em
  }
- \posttitle{\end{center}}

- \preauthor{
      \begin{center}
      \vskip 26em
  }
- \postauthor{\end{center}}
  
- \predate{\begin{center}}
- \postdate{
    \end{center}
    \vskip 4em
  }

output: 
  bookdown::pdf_document2: default
---
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\abstract
\lipsum[1]
\newpage

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)

paquetes <- c("readr", "tidyverse", "showtext", "forecast", "gridExtra",
              "tseries", "tsibble", "kableExtra", "urca")

instalados <- paquetes %in% rownames(installed.packages())

if (any(instalados == FALSE)) {
  install.packages(paquetes[!instalados])
}

invisible(lapply(paquetes, library, character.only = TRUE))

theme_set(theme_bw())
```

```{r}
incorrelation <- function(ts, type = c("Ljung-Box","Box-Pierce"), fitdf = 0){
  p_ljung_box = NULL
  s_ljung_box = NULL
  for(i in 0:(length(ts)/4)){
    p_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$p.value
    s_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$statistic
  }
  table = data.frame(lag = 1:(length(ts)/4),
                     pvalue = p_ljung_box,
                     estadístico = s_ljung_box)
  return(table)
}

test_incorrelation <- function(ts, title = "Pruebas de Incorrelacion") {
  i_box_pierce <- incorrelation(ts, "Box-Pierce")
  i_ljung_box <- incorrelation(ts, "Ljung-Box")
  
  test_incorrelation_data <- merge(i_box_pierce, i_ljung_box, by="lag", suffixes = c("",""))
  
  test_incorrelation_data %>%
      kable(booktabs = T, caption = title, digits = 3) %>%
      column_spec(2, color = ifelse(test_incorrelation_data[2] > 0.05, "blue", "black")) %>% 
      column_spec(4, color = ifelse(test_incorrelation_data[4] > 0.05, "blue", "black")) %>% 
      add_header_above(c(" " = 1, "Box-Pierce" = 2, "Ljung-Box" = 2)) %>%
      kable_styling(latex_options = c("striped", "hold_position"), full_width = F, font_size = 7)
}

aic_grid_search <- function(ts, p = 1, q = 1){
  require(forecast)
  expand.grid(0:p, 0:q) %>% 
    rename(p = Var1, q = Var2) %>%
    mutate(aic = map2_dbl(p, q, function(p, q){AIC(arima(ts, order = c(p,0,q), include.mean = F, method="ML"))}))
}

bic_grid_search <- function(ts, p = 1, q = 1){
  require(forecast)
  expand.grid(0:p, 0:q) %>% 
    rename(p = Var1, q = Var2) %>%
    mutate(bic = map2_dbl(p, q, function(p, q){BIC(arima(ts, order = c(p,0,q), include.mean = F, method="ML"))}))
}
```

<!-- datos -->

```{r}
raw_data <- read_csv(
  file = "https://docs.google.com/uc?id=16we_OjrEZxBUwaQKOh3QAoW5YwfcEg1E",
  col_types = cols(fecha = col_date(format = "%d/%m/%Y")))
```

```{r}
indice_precios_consumidor <- raw_data %>%
  select(fecha, indice_precios_consumidor_acumulada)

indice_salarios <- raw_data %>%
  select(fecha, indice_salarios_acumulada)

ts_indice_precios_consumidor <- indice_precios_consumidor$indice_precios_consumidor_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_indice_salarios <- indice_salarios$indice_salarios_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))
```


# Introducción

Las series de tiempo son el resultado de observar valores de una variable aleatoria a lo largo del tiempo en intervalos iguales o desiguales. En el analisis de las series temporales se utilizan metodos que permiten interpretarlas y extraer informacion sobre las relaciones entre los datos de la serie u otras series.

La inflación puede ser un fenómeno producido por múltiples causas. Uno de los supuestos que puede darle origen es el resultado de la distorsión del mercado debido a aumentos salariales. La percepción individual sugiere que los motivos, en la coyuntura actual, son otros: especulación, emisión, devaluación, exportaciones, monopolios formadores de precios, etc.

Analizar como evolucionan conjuntamente en el tiempo el **Índice de precios al consumidor** y el **Índice de salarios** puede brindar soporte a la sospecha planteada. Además, esta comparativa muestra cómo se comporta el poder adquisitivo de un empleado. Es posible determinar si se recompone conforme aumentan los precios, acompaña o se abre una brecha que da cuenta de su disminución. 

La información fue extraída de la página oficial del Instituto Nacional de Estadística y Censos - INDEC Argentina:

- [Índice de precios al consumidor](https://www.indec.gob.ar/ftp/cuadros/economia/sh_ipc_10_21.xls)
- [Índice de salarios](https://www.indec.gob.ar/ftp/cuadros/sociedad/variaciones_salarios_09_21.xls)

Y se considera la variación mensual acumulada estableciendo a Diciembre 2016 como el 100%.

```{r ipc-vs-is, fig.cap="Inflación versus Salarios", fig.height=4, fig.width=10, fig.pos="H"}
ggplot(raw_data, aes(x = fecha)) +
  geom_line(aes(y = indice_precios_consumidor_acumulada), color = "red3") +
  geom_line(aes(y = indice_salarios_acumulada), color = "steelblue") +
  scale_y_continuous(
    name = "Índice de precio al consumidor",
    sec.axis = sec_axis(~., name = "Índice de salarios")) +
  theme(
    axis.title.y = element_text(color = "red3"),
    axis.title.y.right = element_text(color = "steelblue")
  ) +
  labs(x = "Tiempo") +
  ggtitle("Inflación versus Salarios")
```

Predecir el comportamiento de estos índices puede ser de utilidad para estimar el impacto de un nuevo rumbo en la gestión.

TODO: agregar que queremos predecir hasta enero 2022.
TODO: ver si se pueden agregar referencias al indec, o bibliografia.

\newpage

# Marco Teórico

Un proceso autorregresivo de orden $p$, $AR(p)$, es definido de la siguiente manera:

$$
Y_t = \phi_1Y_{t-1} + \phi_2Y_{t-2} + ... + \phi_pY_{t-p} + \varepsilon_t
$$

La idea central es que el valor actual de la serie depende de los $p$ terminos previos de la misma. Es decir, que la serie se explica a si misma.

Por otro lado, un proceso de medias moviles de orden $q$, $MA(q)$, se define de la siguiente manera:

$$
Y_t = \varepsilon_t - \theta_1\varepsilon_{t-1} - \theta_2\varepsilon_{t-2} - ... - \theta_q\varepsilon_{t-q}
$$

De forma que el valor de la serie actual puede ser expresado como un promedio ponderado de los errores pasados de la misma.

Combinando los modelos autorregresivos y los modelos de medias moviles se obtienen los modelos $ARMA(p, q)$. El resultado entonces es:

$$
Y_t = \phi_1Y_{t-1} + \phi_2Y_{t-2} + ... + \phi_pY_{t-p} + \varepsilon_t - \theta_1\varepsilon_{t-1} - \theta_2\varepsilon_{t-2} - ... - \theta_q\varepsilon_{t-q}
$$

Los modelos autorregresivos y de medias moviles son validos para series de tiempo que son _estacionarias_. Se define que una serie es estacionaria de orden 2 cuando sus segundos momentos son constantes a lo largo del tiempo. Es decir, cuando su media y varianza se mantienen constantes.
Por lo contrario, una serie es _no estacionaria_ cuando la tendencia y/o la variabilidad cambian a lo largo del tiempo.

El presente trabajo practico tiene como objetivo el analisis y prediccion las series descriptas anteriormente mediante modelos ARMA.

## Índice de precios al consumidor

### Estacionaridad

En la Figura \@ref(fig:ipc), se observa que la serie de IPC es _no estacionaria_ ya que su media varia a lo largo del tiempo y su funcion de autocorrelacion decrece en forma lineal lentamente. En el siguiente TP, se llevara a cabo un test para confirmar esta conjetura.

```{r ipc, fig.cap="Índice de precios al consumidor", fig.height=5, fig.width=10, fig.pos="H"}
ggtsdisplay(ts_indice_precios_consumidor, main = 'Índice de precios al consumidor')
```

Como se puede asumir que la tendencia de una serie en el instante $t$ es muy proxima a la del instante $t-1$, se puede formular una nueva serie de la manera $Y_t = y_t - y_{t-1}$. Este proceso se define como _diferenciacion_ y permite transformar una serie no estacionaria a estacionaria. 

```{r}
indice_precios_consumidor_ndiffs <- ndiffs(ts_indice_precios_consumidor)
```

Mediante la funcion `ndiffs` de R, se estima que el numero de diferenciaciones necesarias para convertir a la serie IPC en estacionaria (`r indice_precios_consumidor_ndiffs` veces).

La Figura \@ref(fig:ipc-diferenciado) muestra el indice de precios al consumidor diferenciado.

```{r ipc-diferenciado, fig.cap="Índice de precio al consumidor y su tendencia", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_indice_precios_consumidor <- ts_indice_precios_consumidor %>%
  diff(1) %>% 
  diff(1)

ggtsdisplay(dif_ts_indice_precios_consumidor, 
            main = "Índice de precios al consumidor: Diferenciado dos veces")
```    

La funcion de autocorrelacion (ACF) presenta un lag significativo en 6, por lo que el proceso puede ser modelado con un $MA(6)$. Como ninguno de los lags de la funcion de autocorrelacion parcial (PACF) resultan ser significativos, el proceso no puede ser expresado en un $AR(q)$. #TODO: Referencia?

### Modelado

Se procede a modelar la serie separando en train y test. El primero contara los datos desde el inicio hasta abril del 2021. Los datos de testing seran desde mayo del 2021 hasta julio de ese mismo anio.
Se generan dos modelos y se comparan para elegir el mejor segun criterios de informacion.

```{r}
train_data_ipc <- window(dif_ts_indice_precios_consumidor, end = c(2021, 4))
test_data_ipc <- window(dif_ts_indice_precios_consumidor, start = c(2021, 5))
```

Como primer modelo, se propone el $MA(6)$ descripto anteriormente con su $\theta_6$ distinto de cero y los demas $\phi_i=0$, con $i=1,2,3,4,5$ (ver detalle del modelo en [Apendice](#ap-ipc-modelo-ma)). El segundo modelo propuesto es un $MA(2)$ obtenido con la funcion `auto.arima` del paquete `forecast` en R (ver detalle del modelo en [Apendice](#ap-ipc-modelo-auto-arima)). 

```{r}
model_ma_ipc <- arima(train_data_ipc, 
                      order = c(0,0,6), 
                      include.mean = F, 
                      fixed = c(0, 0, 0, 0, 0, NA))
model_auto_ipc <- auto.arima(train_data_ipc)
```


### Métricas de performance

Las metricas de los modelos propuestos se detallan a continuacion.

```{r modelos-ipc}
forecast_model_ma_ipc <- forecast(model_ma_ipc, h = length(test_data_ipc))
accuracy_model_ma_ipc <- accuracy(test_data_ipc, forecast_model_ma_ipc$mean)

forecast_model_auto_ipc <- forecast(model_auto_ipc, h = length(test_data_ipc))
accuracy_model_auto_ipc <- accuracy(test_data_ipc, forecast_model_auto_ipc$mean)

metrics_model_ma_ipc <- accuracy_model_ma_ipc %>%
  as_tibble() %>%
  add_column(Modelo = "ACF/PACF: MA(6)", 
             AIC = AIC(model_ma_ipc),
             BIC = BIC(model_ma_ipc), .before = "ME")
metrics_model_auto_ipc <- accuracy_model_auto_ipc %>%
  as_tibble() %>%
  add_column(Modelo = "auto.arima: MA(2)", 
             AIC = AIC(model_auto_ipc),
             BIC = BIC(model_auto_ipc), .before = "ME")

rbind(metrics_model_ma_ipc, metrics_model_auto_ipc) %>%
  select(Modelo, AIC, BIC, ME, RMSE) %>% 
  kable(booktabs = T, caption = "Métricas de performance de los modelos sobre IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

El modelo $MA(6)$ es elegido por sobre al $MA(2)$ ya que si bien ambos "empatan" en cuanto a los criterios AIC y BIC, el primero es mas parsimonioso por tener un solo parametro $\theta_6$.

### Análisis de diagnóstico

Se detalla el analisis de los residuos del modelo elegido en la Figura \@ref(fig:residuos-modelo-ipc).

```{r residuos-modelo-ipc, fig.cap="Residuos modelo MA(6) para IPC", fig.height=3.5, fig.width=10, warning=FALSE, fig.pos="H"}
residuos_ma <- residuals(model_ma_ipc)

ggtsdisplay(residuos_ma, 
            lag.max = 24, 
            main = "Residuos MA(6)", 
            plot.type = "histogram")
```

El modelo presenta un buen ajuste debido a que sus residuos son "white noise", es decir, no estan autocorrelados y $\varepsilon\sim~N(0,1)$. 

```{r lb-residuos-modelo-ipc}
test_incorrelation(residuals(model_ma_ipc), title = "Pruebas de incorrelacion de los residuos del modelo MA(6) de IPC")
```

La Tabla \@ref(tab:lb-residuos-modelo-ipc) muestra los valores de los test de Box-Pierce y Ljung-Box para los residuos. Los mismos plantean la siguiente hipotesis:
\begin{align}
  & H_0)\rho_1(Y)=\rho_2(Y)=...=\rho_j(Y)=0, (j=1,2,...) \notag \\
  & H_1)\exists\rho_j(Y)/\rho_j(Y)\neq0 (\#eq:box-pierce)
\end{align}
El test de Box-Pierce utiliza a $\sigma^2(\hat{\rho_j}(Y))\cong1/n$ como estimador de la varianza, lo que produce un sesgo al no rechazo de la hipotesis nula que los $\rho_1(Y)=\rho_2(Y)=...=\rho_j(Y)=0$. #TODO: agregar referencia?. El test de Ljung-Box utiliza otra estimacion de la varianza para corregir el sesgo.

Ambos tests poseen valores no significativos para todos los lags, por lo que no se rechaza la hipotesis nula de coeficientes de autocorrelacion iguales a cero.

```{r}
shapiro_residuos_ma_ipc <- shapiro.test(residuals(model_ma_ipc))[["p.value"]]
```

Para la validar la normalidad de los residuos, se utiliza el test de Shapiro-Wilk. El mismo plantea:
\begin{align}
  H_0)X\sim N(\mu, \sigma^2) \notag \\
  H_1)X\nsim N(\mu, \sigma^2) (\#eq:shapiro-wilk)
\end{align}
El p-value del test es de `r shapiro_residuos_ma_ipc`, mayor a $\alpha=0.05$, por lo que no se puede rechazar la hipotesis de normalidad.

Se concluye que el modelo presenta un buen ajuste a los datos.

### Pronóstico

Se comparan los modelos analizados en una prueba de pronóstico (Fig. 11).

```{r fig.cap="Predicciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
model_arima_ma_ipc <- arima(window(ts_indice_precios_consumidor, end = c(2021, 4)), 
                            order = c(0, 2, 6), 
                            fixed = c(0, 0, 0, 0, 0, NA), 
                            include.mean = F)

autoplot(forecast(model_arima_ma_ipc, h = 9), 
         ylab = 'Porcentaje Acumulado',
         main = 'Indice de Precios al Consumidor')
```


\newpage

## Índice de Salarios

### Estacionaridad

Se puede observar en la gráfica de autocorrelación (Fig. 5) que la serie de Índices de Salarios tiene el mismo comportamiento que la anterior.

```{r fig.cap="Índice de Salarios", fig.height=5, fig.width=10, fig.pos="H"}
ggtsdisplay(ts_indice_salarios, main = "Índice de Salarios")
```


```{r}
indice_salarios_ndiffs <- ndiffs(ts_indice_salarios)
```

Se estima el número de diferenciaciones regulares y estacionales que deberían llevarse a cabo para que la serie sea estacionaria.

- Número de diferenciaciones regulares: `r indice_salarios_ndiffs`

Y se procese a su ejecución conforme el resultado sugerido.

```{r fig.cap="Índice de Salarios y su tendencia", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_indice_salarios <- ts_indice_salarios %>% diff(1)

ggtsdisplay(dif_ts_indice_salarios, 
            main = "Índice de Salarios: Diferenciado")
```
En ambos ACF y PACF los lags 1 son significativos, por lo que se podria modelar con un ARMA(1,1). TODO: referencia

### Modelado


```{r}
train_data_is <- window(dif_ts_indice_salarios, end = c(2021, 04))
test_data_is <- window(dif_ts_indice_salarios, start = c(2021, 05))
```

```{r}
model_arma_is <- arima(train_data_is, order = c(1,0,1))
summary(model_arma_is)
```

```{r}
model_auto_is <- auto.arima(train_data_is)
summary(model_auto_is)
```

### Métricas de performance

Se resumen las métricas para ambos modelos (Tabla 5 y 6).

```{r}
forecast_model_arma_is <- forecast(model_arma_is, h = length(test_data_is))
accuracy_model_arma_is <- accuracy(test_data_is, forecast_model_arma_is$mean)

forecast_model_auto_is <- forecast(model_auto_is, h = length(test_data_is))
accuracy_model_auto_is <- accuracy(test_data_is, forecast_model_auto_is$mean)

metrics_model_arma_is <- accuracy_model_arma_is %>%
  as_tibble() %>%
  add_column(Modelo = "ACF/PACF: ARMA(1,1)", 
             AIC = AIC(model_arma_is),
             BIC = BIC(model_arma_is), .before = "ME")
metrics_model_auto_is <- accuracy_model_auto_is %>%
  as_tibble() %>%
  add_column(Modelo = "auto.arima: SARIMA(1,0,0)(1,0,0)[12]", 
             AIC = AIC(model_auto_is),
             BIC = BIC(model_auto_is), .before = "ME")

rbind(metrics_model_arma_is, metrics_model_auto_is) %>%
  select(Modelo, AIC, BIC, ME, RMSE) %>% 
  kable(booktabs = T, caption = "Métricas de performance", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

TODO: elegimos autoarima

### Análisis de diagnóstico

```{r fig.cap="Residuos", fig.height=3.5, fig.width=10, warning=FALSE, fig.pos="H"}
ggtsdisplay(residuals(model_auto_is), 
            lag.max = 24, 
            main = 'Residuos SARIMA(1,0,0)(1,0,0)[12]', 
            plot.type = "histogram")
```

Los residuos del modelo elegido no estan autocorrelacionados y se distribuyen aproximadamente normal.
Se confirman dichos hipotesis con los siguientes tests.

```{r}
test_incorrelation(residuals(model_auto_is))
```

Los tests coinciden que no existe correlacion en los residuos del modelo.

La normalidad de los errores se corrobora a partir del test de Shapiro-Wilk con un p-value `r shapiro.test(residuals(model_auto_is))[["p.value"]]`.

### Pronóstico

Se comparan los modelos analizados en una prueba de pronóstico (Fig. 11).

```{r fig.cap="Predicciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
model_arima_auto_is <- auto.arima(window(ts_indice_salarios, end = c(2021, 4)))
autoplot(forecast(model_arima_auto_is, h = 9), 
         ylab = 'Porcentaje Acumulado',
         main = 'Indice de Salarios')
```

\newpage

# Análisis de Resultados
\lipsum[1]
\newpage

# Conclusiones
\lipsum[1]
\newpage

# Referencias bibliográficas
\lipsum[1]
\newpage

# Apéndices

## Modelo MA(6) para IPC {#ap-ipc-modelo-ma}

```{r}
summary(model_ma_ipc)
```

## Modelo auto.arima para IPC {#ap-ipc-modelo-auto-arima}

```{r}
summary(model_auto_ipc)
```



## Decomposición

### Índice de precios al consumidor

```{r fig.cap="Funciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
decompose_plot <- dif_ts_indice_precios_consumidor %>%
  decompose(type = "additive") %>%
  autoplot(ts.colour = "steelblue")
decompose_plot + xlab("Tiempo") + ggtitle("Descoposición aditiva")
```

### Índice de Salarios

```{r fig.cap="Funciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
decompose_plot <- dif_ts_indice_salarios %>%
  decompose(type = "additive") %>%
  autoplot(ts.colour = "steelblue")
decompose_plot + xlab("Tiempo") + ggtitle("Descoposición aditiva")
```
