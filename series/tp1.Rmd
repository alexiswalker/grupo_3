---
title:  | 
        Trabajo Práctico N° 1
subtitle: |
          Análisis de Series Temporales
      
          Maestría en Explotación de Datos y Gestión del Conocimiento
author: |
        Layla Scheli, Franco Lianza, Lucio Scalzo, Ignacio Mujica, Alexis Walker
date: |
      `r format(Sys.time(), '%d %B %Y')`


header-includes:
- \usepackage{titling}
- \usepackage{floatrow}
- \usepackage{lipsum}

- \renewcommand{\figurename}{Fig.}
- \renewcommand{\contentsname}{Índice}
- \renewcommand{\tablename}{Tabla}

- \pretitle{
      \begin{center}
      \thispagestyle{empty}
      \includegraphics[width=2in,height=2in]{logo.png}\LARGE\\
      \vskip 12em
  }
- \posttitle{\end{center}}

- \preauthor{
      \begin{center}
      \vskip 26em
  }
- \postauthor{\end{center}}
  
- \predate{\begin{center}}
- \postdate{
    \end{center}
    \vskip 4em
  }

output: 
  pdf_document
---
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\abstract
\lipsum[1]
\newpage

\thispagestyle{empty}
\setcounter{tocdepth}{4}
\tableofcontents
\newpage

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r message=FALSE}
paquetes <- c("readr", "tidyverse", "showtext", "forecast", "gridExtra",
              "tseries", "tsibble", "kableExtra")

#, "gridExtra", "kableExtra", "tseries", "xts",
#              , "ggfortify", "lessR", "fable", "tsibble",
#              "tibbletime"

instalados <- paquetes %in% rownames(installed.packages())

if (any(instalados == FALSE)) {
  install.packages(paquetes[!instalados])
}

invisible(lapply(paquetes, library, character.only = TRUE))
```

```{r}
theme_set(theme_bw())
```

<!-- utilizades -->

```{r}
#TODO
showtext_auto()

plot_acf_pacf <- function(time_serie){
  p_acf <- ggAcf(time_serie, type = "correlation") +
    ggtitle("Autocorrelación") + labs(y = "Autocorrelación")
  
  p_pacf <- ggAcf(time_serie, type = "partial") +
    ggtitle("Autocorrelación Parcial") + labs(y = "Autocorrelación Parcial" )
  
  grid.arrange(p_acf, p_pacf, ncol=2)
}

incorrelation <- function(ts, type = c("Ljung-Box","Box-Pierce"), fitdf = 0){
  p_ljung_box = NULL
  s_ljung_box = NULL
  for(i in 0:(length(ts)/4)){
    p_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$p.value
    s_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$statistic
  }
  table = data.frame(lag = 1:(length(ts)/4),
                     pvalue = p_ljung_box,
                     estadístico = s_ljung_box)
  return(table)
}

aic_grid_search <- function(ts, p = 1, q = 1){
  require(forecast)
  expand.grid(0:p, 0:q) %>% 
    rename(p = Var1, q = Var2) %>%
    mutate(aic = map2_dbl(p, q, function(p, q){AIC(arima(ts, order = c(p,0,q), include.mean = F))}))
}

bic_grid_search <- function(ts, p = 1, q = 1){
  require(forecast)
  expand.grid(0:p, 0:q) %>% 
    rename(p = Var1, q = Var2) %>%
    mutate(bic = map2_dbl(p, q, function(p, q){BIC(arima(ts, order = c(p,0,q), include.mean = F))}))
}
```

<!-- datos -->

```{r}
raw_data <- read_csv(
  file = "https://docs.google.com/uc?id=16we_OjrEZxBUwaQKOh3QAoW5YwfcEg1E",
  col_types = cols(fecha = col_date(format = "%d/%m/%Y")))
```

```{r}
indice_precios_consumidor <- raw_data %>%
  select(fecha, indice_precios_consumidor_acumulada)

indice_salarios <- raw_data %>%
  select(fecha, indice_salarios_acumulada)

ts_indice_precios_consumidor <- indice_precios_consumidor$indice_precios_consumidor_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_indice_salarios <- indice_salarios$indice_salarios_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))
```

# Introducción

La inflación puede ser un fenómeno producido por múltiples causas. Uno de los supuestos que pudiese darle origen es el resultado de la distorsión del mercado debido al aumentos salarial. La percepción individual sugiere que los motivos, en la coyuntura actual, son otros: especulación, emisión, devaluación, exportaciones, monopolios formadores de precios.

Analizar como evolucionan conjuramente en el tiempo el **Índice de precios al consumidor** y el **Índice de salarios** puede brindar soporte a la sospecha planteada. Además esta comparativa muestra cómo se comporta el poder adquisitivo de un empleado. Es posible determinar si se recompone conforme aumentan los precios, acompaña o se abre una brecha que da cuenta de su disminución. 

La información fue extraída de la página oficial del Instituto Nacional de Estadística y Censos - INDEC Argentina:

- [Índice de precios al consumidor](https://www.indec.gob.ar/ftp/cuadros/economia/sh_ipc_10_21.xls)
- [Índice de salarios](https://www.indec.gob.ar/ftp/cuadros/sociedad/variaciones_salarios_09_21.xls)


```{r fig.cap="Inflación versus Salarios", fig.height=4, fig.width=10, fig.pos="H"}
ggplot(raw_data, aes(x = fecha)) +
  geom_line(aes(y = indice_precios_consumidor_acumulada), color = "red3") +
  geom_line(aes(y = indice_salarios_acumulada), color = "steelblue") +
  scale_y_continuous(
    name = "Índice de precio al consumidor",
    sec.axis = sec_axis(~., name = "Índice de salarios")) +
  theme(
    axis.title.y = element_text(color = "red3"),
    axis.title.y.right = element_text(color = "steelblue")
  ) +
  labs(x = "Tiempo") +
  ggtitle("Inflación versus Salarios")
```

Predecir el comportamiento de estos índices puede ser de utilizas para estimar el impacto de un nuevo rumbo en la gestión.

\newpage

# Marco Teórico

Ambas series temporales exhiben una marcada tendencia creciente que hace suponer una media también creciente en el tiempo, por lo que es probable que el proceso estocástico que la ha generado no sea estacionario en media.

## Estacionariedad

A fin de mejorar la normalidad de los datos se analiza la tendencia y estacionalidad. La diferenciación es el instrumento que permite eliminar estos componentes para conseguir estacionariedad.

### Índice de precios al consumidor

Se puede observar en la gráfica de autocorrelación (Fig. 2) como la serie no es estacionaria ya que el valor de la función no decae de manera exponencial (se comportar como si se tratase de un camino aleatorio). También se aprecia que no parece existir un componente estacional.

```{r fig.cap="Índice de precios al consumidor", fig.height=2.3, fig.width=10, fig.pos="H"}
plot_acf_pacf(ts_indice_precios_consumidor)
```

```{r}
indice_precios_consumidor_ndiffs <- ndiffs(ts_indice_precios_consumidor)
indice_precios_consumidor_nsdiffs <- nsdiffs(ts_indice_precios_consumidor)
```

Se estima el número de diferenciaciones regulares y estacionales que deberían llevarse a cabo para que la serie sea estacionaria.

- Número de diferenciaciones regulares: `r indice_precios_consumidor_ndiffs`
- Número de diferenciaciones estacionales: `r indice_precios_consumidor_nsdiffs`

Y se procese a su ejecución conforme el resultado sugerido.


```{r fig.cap="Índice de precio al consumidor y su tendencia", fig.height=2.3, fig.width=10, fig.pos="H"}
dif_ts_indice_precios_consumidor <- ts_indice_precios_consumidor %>%
  diff(1) %>%
  diff(1)

dif_indice_precios_consumidor <- data.frame(
  indice_precios_consumidor = as.vector(dif_ts_indice_precios_consumidor),
  fecha = indice_precios_consumidor$fecha[c(-1, -2)])

ggplot(dif_indice_precios_consumidor, aes(x = fecha, y = indice_precios_consumidor)) +
  geom_line(color = "steelblue") +
  stat_smooth(method = "lm", col = "red3", formula = y ~ x, size = 0.4, se = FALSE) +
  scale_y_continuous(name = "Índice de precio al consumidor") +
  labs(x = "Tiempo") +
  ggtitle("Índice de precio al consumidor")
```    

Luego de presentar el resultado (Fig. 3) junto a un modelo lineal simple, se entiende que se ha conseguido estacionariedad en la media.

```{r fig.cap="Índice de precios al consumidor", fig.height=2.3, fig.width=10, fig.pos="H"}
plot_acf_pacf(dif_ts_indice_precios_consumidor)
```

Se repite el análisis de autocorrelaciones (Fig. 4), ahora el resultado tiene el comportamiento de un camino aleatorio diferenciado.

Se formalizan las conclusiones realizando las prueblas Ljung-Box y, su versión simplificada, Box-Pierce.

```{r warning=FALSE}
i_box_pierce_indice_precios_consumidor <- incorrelation(dif_ts_indice_precios_consumidor,"Box-Pierce")
i_ljung_box_indice_precios_consumidor <- incorrelation(dif_ts_indice_precios_consumidor, "Ljung-Box")

test_data_indice_precios_consumidor <- merge(i_box_pierce_indice_precios_consumidor, i_ljung_box_indice_precios_consumidor, by="lag", suffixes = c("",""))

test_data_indice_precios_consumidor %>%
    kable(booktabs = T, caption = "Pruebas de autocorrelación", digits = 3) %>%
    column_spec(2, color =  ifelse(test_data_indice_precios_consumidor[2] > 0.05, "blue", "black")) %>% 
    column_spec(4, color =  ifelse(test_data_indice_precios_consumidor[4] > 0.05, "blue", "black")) %>% 
    add_header_above(c(" " = 1, "Box-Pierce" = 2, "Ljung-Box" = 2)) %>%
    kable_styling(latex_options = c("striped", "hold_position"), full_width = F, font_size = 7)
```

P-values significativos (Tabla 1) por lo que no se rechaza la hipótesis nula; las autocorrelaciones son igual a cero: se distribuyen de forma independiente. <esta bien?? :(>

### Índice de Salarios

Se puede observar en la gráfica de autocorrelación (Fig. 5) que la serie de Índices de Salarios tiene el mismo comportamiento que la anterior.

```{r fig.cap="Índice de Salarios", fig.height=2.3, fig.width=10, fig.pos="H"}
plot_acf_pacf(ts_indice_salarios)
```


```{r}
indice_salarios_ndiffs <- ndiffs(ts_indice_salarios)
indice_salarios_nsdiffs <- nsdiffs(ts_indice_salarios)
```


Se estima el número de diferenciaciones regulares y estacionales que deberían llevarse a cabo para que la serie sea estacionaria.

- Número de diferenciaciones regulares: `r indice_salarios_ndiffs`
- Número de diferenciaciones estacionales: `r indice_salarios_nsdiffs`

Y se procese a su ejecución conforme el resultado sugerido.

```{r fig.cap="Índice de Salarios y su tendencia", fig.height=2.3, fig.width=10, fig.pos="H"}
dif_ts_indice_salarios <- ts_indice_salarios %>% diff(1)

dif_indice_salarios <- data.frame(
  indice_salarios = as.vector(dif_ts_indice_salarios),
  fecha = indice_salarios$fecha[c(-1)])

ggplot(dif_indice_salarios, aes(x = fecha, y = indice_salarios)) +
  geom_line(color = "steelblue") +
  stat_smooth(method = "lm", col = "red3", formula = y ~ x, size = 0.4, se = FALSE) +
  scale_y_continuous(name = "Índice de Salarios") +
  labs(x = "Tiempo") +
  ggtitle("Índice de Salarios")
```

A pesar de la sugerencia del número de diferenciaciones, no parece eliminarse la tendencia (Fig. 6). Por lo que se repite el procedimiento una vez más.

```{r fig.cap="Índice de Salarios y su tendencia", fig.height=2.3, fig.width=10, fig.pos="H"}
dif_ts_indice_salarios <- ts_indice_salarios %>% diff(1) %>% diff(1)

dif_indice_salarios <- data.frame(
  indice_salarios = as.vector(dif_ts_indice_salarios),
  fecha = indice_salarios$fecha[c(-1, -2)])

ggplot(dif_indice_salarios, aes(x = fecha, y = indice_salarios)) +
  geom_line(color = "steelblue") +
  stat_smooth(method = "lm", col = "red3", formula = y ~ x, size = 0.4, se = FALSE) +
  scale_y_continuous(name = "Índice de Salarios") +
  labs(x = "Tiempo") +
  ggtitle("Índice de Salarios")
```

El resultado (Fig. 7) junto a un modelo lineal simple, muestra la estacionariedad en la media.

```{r fig.cap="Índice de precios al consumidor", fig.height=2.3, fig.width=10, fig.pos="H"}
plot_acf_pacf(dif_ts_indice_salarios)
```

Se repite el análisis de autocorrelaciones (Fig. 8), ahora el resultado tiene el comportamiento de un camino aleatorio diferenciado.

```{r warning=FALSE}
i_box_pierce_indice_salario <- incorrelation(dif_ts_indice_salarios,"Box-Pierce")
i_ljung_box_indice_salario <- incorrelation(dif_ts_indice_salarios, "Ljung-Box")

test_data_indice_salario <- merge(i_box_pierce_indice_salario, i_ljung_box_indice_salario, by="lag", suffixes = c("",""))

test_data_indice_salario %>%
    kable(booktabs = T, caption = "Pruebas de autocorrelación", digits = 3) %>%
    column_spec(2, color =  ifelse(test_data_indice_salario[2] > 0.05, "blue", "black")) %>% 
    column_spec(4, color =  ifelse(test_data_indice_salario[4] > 0.05, "blue", "black")) %>% 
    add_header_above(c(" " = 1, "Box-Pierce" = 2, "Ljung-Box" = 2)) %>%
    kable_styling(latex_options = c("striped", "hold_position"), full_width = F, font_size = 7)
```


(Tabla 2)<que conclusión sacar?>

\newpage

## Modelos

Una vez transformada la información para satisfacer los supuestos de los modelos a utilizar, se estiman los parámetros que mejoran su comportamiento.

### Índice de precios al consumidor

#### Estimación

Se calculan, para la serie temporal, distintos órdenes de parámetros del modelo ARMA y se comparan AIC y BIC como criterios de información.

```{r warning=FALSE, fig.cap="Criterios de Información", fig.height=3.5, fig.width=8, fig.pos="H"}

aic_data_indice_precios_consumidor <- aic_grid_search(dif_ts_indice_precios_consumidor, 3, 7)

aic_plot <- ggplot(aic_data_indice_precios_consumidor, aes(p, q)) +
  geom_tile(aes(fill = aic)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = aic, label = round(aic, 2))) +
  ggtitle("AIC")

bic_data_indice_precios_consumidor <- bic_grid_search(dif_ts_indice_precios_consumidor, 3, 7)

bic_plot <- ggplot(bic_data_indice_precios_consumidor, aes(p, q)) +
  geom_tile(aes(fill = bic)) + 
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = bic, label = round(bic, 2)))  +
  ggtitle("BIC")

grid.arrange(aic_plot, bic_plot, ncol=2)

```

En ambos casos, el modelo sugerido es ARMA(1, 1) (Fig. 9).

```{r}
train_data_ipc <- window(dif_ts_indice_precios_consumidor, end= c(2020, 12))

test_data_ipc <- window(dif_ts_indice_precios_consumidor, start= c(2021, 01))
```

#### Métrica de performance

Se resumen las métricas del modelo propuesto (Tabla 3).

```{r}
model_aic_bic_ipc <- arima(train_data_ipc, order = c(1,0,1), include.mean = F)

my_forecast_ipc <- forecast(model_aic_bic_ipc, h = length(test_data_ipc))

accuracy_aic_bic_ipc <- accuracy(test_data_ipc, my_forecast_ipc$mean)
```

```{r}
metrics_aic_bic_ipc<- accuracy_aic_bic_ipc %>%
  as_tibble() %>%
  add_column(Modelo = "arima(order = c(1, 0, 1))", .before = "ME")

metrics_aic_bic_ipc %>%
  kable(booktabs = T, caption = "Métricas", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


#### Comparación

Existen herramientas para determinar automáticamente un modelo que mejor ajuste. Se aprovecha esta posibilidad y se compara con el modelo antes elegido.

```{r}
auto_model_ipc <- auto.arima(train_data_ipc)
my_forecast_auto_ipc <- forecast(auto_model_ipc, h = length(test_data_ipc))
acurracy_auto_ipc <- accuracy(test_data_ipc, my_forecast_auto_ipc$mean)
```

```{r}
metrics_auto_ipc <- acurracy_auto_ipc %>%
  as_tibble() %>%
  add_column(Modelo = "auto: ARIMA(1,0,1)", .before = "ME")

rbind(metrics_aic_bic_ipc, metrics_auto_ipc) %>%
  kable(booktabs = T, caption = "Métricas", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Ambos análisis conducen al mismo resultado (Tabla 4).

#### Análisis de Diagnóstico

Visualmente no se evidencia tendencia, por lo que se asumir que la media y varianza son constantes. El histograma (Fig. 10) muestra con comportamiento normal con media cero; lo que se corrobora a partir del test de Shapiro-Wilk con un p-value `r shapiro.test(residuals(auto_model_ipc))[["p.value"]]`. El gráfico de autocorrelación se asemeja al del ruido blanco: p-value `r Box.test(residuals(auto_model_ipc), lag = 1, type = "Ljung-Box", fitdf = 0)$p.value` del test Ljung-Box con lag igual a 1.

```{r fig.cap="Residuos", fig.height=3.5, fig.width=10, warning=FALSE, fig.pos="H"}
ggtsdisplay(residuals(auto_model_ipc), lag.max = 24, main = 'Residuos', plot.type = "histogram")
```

#### Pronóstico

Se comparan los modelos analizados en una prueba de pronóstico (Fig. 11).

```{r fig.cap="Pronóstico", fig.height=2.3, fig.width=10}

colors <- c("train" = "blue", "test" = "red", "forecast" = "orange", "auto" = "gray")
ggplot() +
  geom_line(data = as_tsibble(train_data_ipc), aes(x = index, y = value, color = "train")) +
  geom_line(data = as_tsibble(test_data_ipc), aes(x = index, y = value, color = "test")) +
  geom_line(data = as_tsibble(forecast(model_aic_bic_ipc, h = 7)$mean), aes(x = index, y = value, color = "forecast")) +
  geom_line(data = as_tsibble(forecast(auto_model_ipc, h = 7)$mean), aes(x = index, y = value, color = "auto")) +
  scale_color_manual(name = "", values = colors) +
  labs(x = "Tiempo") +
  ggtitle("Pronóstico")

```

\newpage

### Índice de Salarios

#### Estimación

Se calculan, para la serie temporal, distintos órdenes de parámetros del modelo ARMA y se comparan AIC y BIC como criterios de información (Fig. 12).

```{r warning=FALSE, fig.cap="Criterios de Información", fig.height=3.5, fig.width=10, fig.pos="H"}

aic_data_is <- aic_grid_search(dif_ts_indice_salarios, 3, 7)

aic_plot_is <- ggplot(aic_data_is, aes(p, q)) +
  geom_tile(aes(fill = aic)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = aic, label = round(aic, 2))) +
  ggtitle("AIC")

bic_data_is <- bic_grid_search(dif_ts_indice_salarios, 3, 7)

bic_plot_is <- ggplot(bic_data_is, aes(p, q)) + 
  geom_tile(aes(fill = bic)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  geom_text(aes(fill = bic, label = round(bic, 2)))  +
  ggtitle("BIC")

grid.arrange(aic_plot_is, bic_plot_is, ncol=2)
```

En este caso:

- AIC sugiere un p igual 1 y un q = 3.
- BIC sugiere un p igual a q igual a 1.

```{r}
train_data_is <- window(dif_ts_indice_salarios, end= c(2020, 12))

test_data_is <- window(dif_ts_indice_salarios, start= c(2021, 01))
```

#### Métrica de performance

Se resumen las métricas para ambos modelos (Tabla 5 y 6).

```{r}
model_aic_is <- arima(train_data_is, order = c(1,0,3), include.mean = F)
my_forecast_aic_is <- forecast(model_aic_is, h = length(test_data_is))
accuracy_aic_is <- accuracy(test_data_is, my_forecast_aic_is$mean)

model_bic_is <- arima(train_data_is, order = c(1,0,1), include.mean = F)
my_forecast_bic_is <- forecast(model_bic_is, h = length(test_data_is))
accuracy_bic_is <- accuracy(test_data_is, my_forecast_bic_is$mean)  
```

```{r}
metrics_aic_is <- accuracy_aic_is %>%
  as_tibble() %>%
  add_column(Modelo = "arima(order = c(1, 0, 3))", .before = "ME")

metrics_aic_is %>%
  kable(booktabs = T, caption = "Mejor modelos según AIC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

```{r}
metrics_bic_is <- accuracy_bic_is %>%
  as_tibble() %>%
  add_column(Modelo = "arima(order = c(1, 0, 1))", .before = "ME")

metrics_bic_is %>%
  kable(booktabs = T, caption = "Mejor modelos según BIC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

#### Comparación

Nuevamente se aprovecha la posibilidad de determinar automaticamente un buen modelo y se suma el resultado a lo ya planteado (Tabla 7).

```{r}
auto_model_is <- auto.arima(train_data_is)
my_forecast_auto_is <- forecast(auto_model_is, h = length(test_data_is))
accuracy_auto_is <- accuracy(test_data_is, my_forecast_auto_is$mean)  
```

```{r}
metrics_auto_is <- accuracy_auto_is %>%
  as_tibble() %>%
  add_column(Modelo = "auto: ARIMA(0,0,0)(1,0,0)[12]", .before = "ME")

rbind(metrics_aic_is, metrics_bic_is, metrics_auto_is) %>%
  kable(booktabs = T, caption = "Métricas", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"))
```

El mejor es ?? 

#### Análisis de Diagnóstico

Visualmente no se evidencia tendencia, por lo que se asumir que la media y varianza son constantes. El histograma (Fig. 13) muestra con comportamiento normal con media cero; lo que se corrobora a partir del test de Shapiro-Wilk con un p-value `r shapiro.test(residuals(auto_model_is))[["p.value"]]`. El gráfico de autocorrelación se asemeja al del ruido blanco: p-value `r Box.test(residuals(auto_model_is), lag = 1, type = "Ljung-Box", fitdf = 0)$p.value` del test Ljung-Box con lag igual a 1.

```{r fig.cap="Residuos", fig.height=3.5, fig.width=10, warning=FALSE}
residuals_is <- resid(auto_model_is)
checkresiduals(residuals_is)
```

#### Pronóstico

Se comparan los modelos analizados en una prueba de pronóstico (Fig. 11).

```{r fig.cap="Pronóstico", fig.height=2.3, fig.width=10}

colors <- c("train" = "blue", "test" = "red", "aic" = "orange", "bic" = "gray", "auto" = "black")
ggplot() +
  geom_line(data = as_tsibble(train_data_is), aes(x = index, y = value, color = "train")) +
  geom_line(data = as_tsibble(test_data_is), aes(x = index, y = value, color = "test")) +
  geom_line(data = as_tsibble(forecast(model_aic_is, h = 7)$mean), aes(x = index, y = value, color = "aic")) +
  geom_line(data = as_tsibble(forecast(model_bic_is, h = 7)$mean), aes(x = index, y = value, color = "bic")) +
  geom_line(data = as_tsibble(forecast(auto_model_is, h = 7)$mean), aes(x = index, y = value, color = "auto")) +
  scale_color_manual(name = "", values = colors) +
  labs(x = "Tiempo") +
  ggtitle("Pronóstico")
```

\newpage

# Análisis de Resultados
\lipsum[1]
\newpage

# Conclusiones
\lipsum[1]
\newpage

# Referencias bibliográficas
\lipsum[1]
\newpage

# Apéndices

## Decomposición

### Índice de precios al consumidor

```{r fig.cap="Funciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
decompose_plot <- dif_ts_indice_precios_consumidor %>%
  decompose(type = "additive") %>%
  autoplot(ts.colour = "steelblue")
decompose_plot + xlab("Tiempo") + ggtitle("Descoposición aditiva")
```

### Índice de Salarios

```{r fig.cap="Funciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
decompose_plot <- dif_ts_indice_salarios %>%
  decompose(type = "additive") %>%
  autoplot(ts.colour = "steelblue")
decompose_plot + xlab("Tiempo") + ggtitle("Descoposición aditiva")
```
