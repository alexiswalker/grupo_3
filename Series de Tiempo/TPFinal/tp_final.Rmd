---
title:  | 
  Trabajo Práctico Final
subtitle: |
  Análisis de Series Temporales
      
  Maestría en Explotación de Datos y Gestión del Conocimiento
author: |
  Layla Scheli, Franco Lianza, Lucio Scalzo, Ignacio Mujica, Alexis Walker
date: |
  `r format(Sys.time(), '%d %B %Y')`
bibliography: bibliografia.bib
biblio-style: "apa"
link-citations: true

header-includes:
- \usepackage{titling}
- \usepackage{floatrow}

- \renewcommand{\figurename}{Fig.}
- \renewcommand{\contentsname}{Índice}
- \renewcommand{\tablename}{Tabla}

- \pretitle{
      \begin{center}
      \thispagestyle{empty}
      \includegraphics[width=2in,height=2in]{logo.png}\LARGE\\
      \vskip 12em
  }
- \posttitle{\end{center}}

- \preauthor{
      \begin{center}
      \vskip 26em
  }
- \postauthor{\end{center}}
  
- \predate{\begin{center}}
- \postdate{
    \end{center}
    \vskip 4em
  }

output: 
  bookdown::pdf_document2: default
---

\thispagestyle{empty}
\newpage

\thispagestyle{empty}

\abstract

\setlength{\parskip}{0.5em}
\setlength{\parindent}{0em}

\noindent El presente trabajo tiene por objetivo estudiar la relación entre dos variables económicas fundamentales, el IPC (Indice de precios al Consumidor) y el índice de Salarios.

Ambos indicadores son considerados fundamentales para el desarrollo de un país ya que conllevan, en la relación entre ambos, dos efectos antagónicos según se comporten. 

Por un lado, cómo evoluciona en nivel de vida de la población. Si los salarios se incrementan en mayor proporción que los bienes y servicios, consiguientemente se mejora el bienestar además del incremento de la producción ocasionando mayor demanda.

Por otro, como se demostrará en el desarrollo del presente. Si los indicadores de incremento de bienes y servicios crecen a mayor ritmo que los salarios, disminuye el bienestar de la masa asalariada.

Como resultado de este proceso inflacionario y de baja demanda interna hay que mencionar que esto perjudica a los sectores productivos internos.

Las causas que originan el fenómeno de inflación no serán tratadas por lo complejo y extenso que es el tema.

\newpage

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

```{r, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	fig.pos = "H",
	warning = FALSE,
	out.extra = ""
)
```

```{r setup, include=FALSE}
paquetes <- c("readr", "tidyverse", "forecast", "gridExtra",
              "tseries", "tsibble", "kableExtra", "vars")

instalados <- paquetes %in% rownames(installed.packages())

if (any(instalados == FALSE)) {
  install.packages(paquetes[!instalados])
}

invisible(lapply(paquetes, library, character.only = TRUE))

theme_set(theme_bw())
```

```{r}
incorrelation <- function(ts, type = c("Ljung-Box","Box-Pierce"), fitdf = 0){
  p_ljung_box = NULL
  s_ljung_box = NULL
  for(i in 0:(length(ts)/4)){
    p_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$p.value
    s_ljung_box[i] = Box.test(ts, lag = i, type = type, fitdf = fitdf)$statistic
  }
  table = data.frame(lag = 1:(length(ts)/4),
                     pvalue = p_ljung_box,
                     estadístico = s_ljung_box)
  return(table)
}

test_incorrelation <- function(ts, title = "Pruebas de Incorrelacion") {
  i_box_pierce <- incorrelation(ts, "Box-Pierce")
  i_ljung_box <- incorrelation(ts, "Ljung-Box")
  
  test_incorrelation_data <- merge(i_box_pierce, i_ljung_box, by="lag", suffixes = c("",""))
  
  test_incorrelation_data %>%
      kable(booktabs = T, caption = title, digits = 3) %>%
      column_spec(2, color = ifelse(test_incorrelation_data[2] > 0.05, "blue", "black")) %>% 
      column_spec(4, color = ifelse(test_incorrelation_data[4] > 0.05, "blue", "black")) %>% 
      add_header_above(c(" " = 1, "Box-Pierce" = 2, "Ljung-Box" = 2)) %>%
      kable_styling(latex_options = c("striped", "hold_position"), full_width = F, font_size = 7)
}
```

```{r}
kpss_test <- function(ts){
  kppst <- kpss.test(ts)
  df <- data.frame(kppst$statistic, kppst$p.value, kppst$parameter)
  colnames(df) <- c("Estadístico", "P-Value", "Lag")
  rownames(df) <- NULL
  
  return(df)
}

adf_test <- function(ts){
  ur_df <- ur.df(ts, selectlags = "AIC", type = "trend")
  df <- cbind(as.data.frame(t(ur_df@teststat)), ur_df@cval)
  colnames(df)[1] <- "Estadístico"

  return(df)
}

shapiro_wilk_normality_test <- function(residuos){
  sw <- shapiro.test(residuos)
  df <- data.frame(sw$statistic, sw$p.value)
  colnames(df) <- c("Estadístico", "P-Value")
  rownames(df) <- NULL
  
  return(df)
}
```


```{r}
raw_data <- read_csv(
  file = "https://docs.google.com/uc?id=16we_OjrEZxBUwaQKOh3QAoW5YwfcEg1E",
  col_types = cols(fecha = col_date(format = "%d/%m/%Y")))
```



```{r}
ipc <- raw_data %>%
  dplyr::select(fecha, indice_precios_consumidor_acumulada)

is <- raw_data %>%
  dplyr::select(fecha, indice_salarios_acumulada)

bm <- raw_data %>%
  dplyr::select(fecha, variacion_base_monetaria_acumulada)


ts_ipc <- ipc$indice_precios_consumidor_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_is <- is$indice_salarios_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_bm <- bm$variacion_base_monetaria_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))
```


# Introducción

Las series de tiempo son el resultado de observar valores de una variable aleatoria a lo largo del tiempo en intervalos iguales o desiguales. En el análisis de las series temporales se utilizan métodos que permiten interpretarlas y extraer información sobre las relaciones entre los datos de la serie u otras series. 

Según @mochon, _“La inflación es el crecimiento generalizado y continuo de los precios de los bienes y los servicios”_ (p. 496), y el índice de precios al consumidor (IPC) representa el costo de la canasta de bienes y servicios consumidos por la economía local.

El  fenómeno  de la inflación se produce por múltiples causas. Las teorías tradicionales se pueden resumir en: inflación de demanda, que se produce cuando los gastos superan la capacidad de producción de la economía, por causas monetarias, cuando se incrementa la emisión monetaria, la inflación de costos, cuando los precios suben por grupos económicos de presión y la inflación estructural, que es la que se origina debido a los problemas estructurales de las economías en vías de desarrollo.

La percepción individual sugiere que los motivos, en la coyuntura actual, son variados: especulación, emisión desmedida, presión por devaluación, bajas exportaciones, monopolios formadores de precios, elevado gasto público, mercado laboral altamente regulado, etc.

Analizar como evolucionan conjuntamente en el tiempo el Índice de precios al consumidor y el Índice de salarios puede ayudar a clarificar los problemas y soluciones posibles.

Además, esta comparativa muestra cómo se comporta el poder adquisitivo de un empleado. Es posible determinar si se recompone conforme aumentan los precios, acompaña o se abre una brecha que da cuenta de su disminución.

```{r ipc-vs-is-vs-bm, fig.cap="IPC vs IS vs BM", fig.height=4, fig.width=10}
autoplot(ts_ipc, series = 'Índice de Precios al Consumidor') +
  autolayer(ts_is, series = 'Índice de Salarios') +
  autolayer(ts_bm, series = 'Base Monetaria') +
  ggtitle('Índice de Precios al Consumidor, Índice de Salarios acumulados y Base Monetaria',
          subtitle = 'Con base Diciembre 2016') +
  ylab('% de cambio acumulado')
```

La información fue extraída de la página oficial del Instituto Nacional de Estadística y Censos - INDEC Argentina:

- Índice de precios al consumidor
- Índice de salarios
- Base monetaria

Se considera la variación mensual acumulada estableciendo a Diciembre 2016 como el 100% y se pretende predecir los cambios de las series para Enero 2022.

\newpage

# Marco Teórico

Los modelos autorregresivos y de medias móviles son validos para series de tiempo que son _estacionarias_. Se define que una serie es estacionaria de orden 2 cuando sus segundos momentos son constantes a lo largo del tiempo. Es decir, cuando su media y varianza se mantienen constantes.

Por lo contrario, una serie es _no estacionaria_ cuando la tendencia y/o la variabilidad cambian a lo largo del tiempo.

El presente trabajo práctico tiene como objetivo el análisis de la estacionariedad de las series presentadas y su modelado mediante modelos SARIMA.

## Tests de estacionariedad

La estacionariedad puede ser puesta a prueba mediante diferentes tests. Se detallan los dos a utilizar.

### Dickey-Fuller Aumentado

En la ecuación de Dickey-Fuller aumentada \@ref(eq:df):

\begin{equation}
\nabla Y_{t} =  a_{0} + a_{1} t + (\phi_{1} - 1) Y_{t-1} + \epsilon_{t}
(\#eq:df)
\end{equation}

Se pone a prueba el coeficiente que acompaña al rezago del período anterior: $(\phi_{1} - 1)$.

El estadístico de este test es:

\begin{equation}
\tau^{e} = \frac{\hat{\phi_{1}} - \phi_{1}}{\sigma(\hat{\phi_{1}})}
\end{equation}

Se plantea la regla de decisión:

> Si $\tau \leq \tau^{e} < 0 \Rightarrow$ No Rechazar $H_{0}$

> Si $\tau^{e} < \tau \Rightarrow$ Rechazar $H_{0}$

Como se explica en @pena, la hipótesis nula establece que la raíz mayor de un $AR(p+1)$ es igual a uno, por lo que el proceso es no estacionario.

### Kwiatkowski-Phillips-Schmidt-Shin

@kpss definen otra prueba para raíces unitarias en la cual la hipótesis nula es contraria al test ADF, es decir, plantea que la serie temporal observable es estacionaria.

## Transformaciones para estabilizar la media y la varianza

Según lo expresado en @pena, la identificación de las estructuras no estacionarias consiste en detectar qué transformaciones hay que aplicar para conseguir un proceso con media y varianza constante. 

En particular, consiste en determinar si es necesario: transformar la serie para que tenga varianza constante y/o diferenciarla para darle una media constante.

Por un lado, las transformaciones de potencia de Box-Cox son una forma general que permiten convertir el proceso original en un proceso condicionalmente homocedástico.

Por otro, como se puede asumir que la tendencia de una serie en el instante $t$ es muy próxima a la del instante $t-1$, se puede formular una nueva serie de la manera $Y_t = y_t - y_{t-1}$. Este proceso se define como _diferenciación_ y permite transformar una serie no estacionaria a estacionaria.

## Vectores autoregresivos

El modelado ARIMA está limitado por su incapacidad para capturar interrelaciones dinámicas entre variables de interés. La generalización directa del modelo ARMA estacionario a la forma multivariante conduce a un modelo vectorial (@var).

Por variable en el sistema, existe una ecuación, cuyo lado derecho incluye una constante y retrasos de todas las variables presentes. 

Para mantenerlo simple, se presenta un modelo VAR de dos variables con retraso igual a 1 ($p = 1$):

\begin{equation}
  y_{1, t} = c_{1} + \phi_{11, 1} y_{1, t-1} +  \phi_{12, 1} y_{2, t-1} + \epsilon_{1, t}
  (\#eq:varyuno)
\end{equation}

\begin{equation}
  y_{2, t} = c_{2} + \phi_{21, 1} y_{1, t-1} +  \phi_{22, 1} y_{2, t-1} + \epsilon_{2, t}
  (\#eq:varydos)
\end{equation}

Donde $\epsilon_{1, t}$ y $\epsilon_{2, t}$ \~ $N(0,\sigma_{y})$ y no están autocorrelacionados. $y_{1, t}$ y $y_{2, t}$ son estacionarias. El coeficiente $\phi_{ii, p}$ captura la influencia del _lag_ $p$ de la variable $y_{i}$ sobre si misma. Mientras que $\phi_{ij, p}$ determina el peso del _lag_ $p$ de la variable $y_{j}$ sobre $y_{i}$.

\newpage

# Análisis de Resultados


## Vectores Autoregresivos


TODO: aca tendriamos que hacer referencia a que VAR necesita series diferenciadas

### Índice de Precios al Consumidor

#### Analisis de la serie

En la Figura \@ref(fig:ipc), se observa que la serie de IPC es _no estacionaria_ ya que su media varia a lo largo del tiempo y su función de autocorrelación decrece en forma lineal lentamente.

```{r ipc, fig.cap="Índice de precios al consumidor", fig.height=5, fig.width=10}
ggtsdisplay(ts_ipc, main = 'Índice de precios al consumidor')
```

Es posible someter la evidencia gráfica a distintas pruebas estadísticas para ratificar o rectificar lo observado.

**Test de Estacionariedad: ADF**

En la Tabla \@ref(tab:ipc-adf) se observa $\tau^{e}$ entre el valor crítico y cero, lo que determina que no hay evidencia para rechazar $H_{0}$ (serie no estacionaria).

```{r ipc-adf}
adf_test(ts_ipc) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

Los resultados de la prueba se encuentran detallados en la Tabla \@ref(tab:ipc-kpss).

```{r ipc-kpss}
kpss_test(ts_ipc) %>% 
  kable(booktabs = T, caption = "Test KPSS para IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En este caso el p-value es menor al grado de significación 0.05, por lo que se rechaza $H_0$.

En conclusión, ambos tests determinan que la serie de IPC es _no estacionaria_.

#### Diferenciación

```{r}
ipc_ndiffs <- ndiffs(ts_ipc)
```

Mediante la función `ndiffs` de R, se estima que el numero de diferenciaciones necesarias para convertir a la serie IPC en estacionaria (`r ipc_ndiffs` veces).

La Figura \@ref(fig:ipc-diferenciado) muestra el indice de precios al consumidor diferenciado.

```{r ipc-diferenciado, fig.cap="Índice de precio al consumidor diferenciado", fig.height=5, fig.width=10}
dif_ts_ipc <- ts_ipc %>%
  diff(lag = 1, differences = ipc_ndiffs)

ggtsdisplay(dif_ts_ipc, 
            main = "Índice de precios al consumidor: Diferenciado dos veces")
```    

**Test de Estacionariedad: ADF**

Se corrobora que la serie de IPC diferenciada es estacionaria mediante el test Dickey-Fuller aumentado (Tabla \@ref(tab:ipc-dif-adf)). El valor de $\tau^{e}$ se encuentra dentro de la zona de rechazo, por lo que se concluye que se rechaza $H_0$.

```{r ipc-dif-adf}
adf_test(dif_ts_ipc) %>% 
  kable(booktabs = T, caption = "Test de ADF para IPC diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

El test KPSS coincide con ADF. El p-value es mayor al grado de significación de 0.05, por lo que no se rechaza la hipótesis nula de estacionariedad.

```{r ipc-dif-kpss}
kpss_test(dif_ts_ipc) %>% 
  kable(booktabs = T, caption = "Test KPSS para IPC diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Se confirma entonces que la serie diferenciada es _estacionaria_.

### Índice de Salarios

La Figura \@ref(fig:is) muestra la serie de Índice de Salarios.

```{r is, fig.cap="Índice de Salarios", fig.height=5, fig.width=10, fig.pos="H"}
ggtsdisplay(ts_is, main = "Índice de Salarios")
```

#### Analisis de la serie

**Test de Estacionariedad: ADF**

En la Tabla \@ref(tab:is-adf) se observa $\tau^{e}$ entre el valor crítico y cero, lo que determina que no hay evidencia para rechazar $H_{0}$.

```{r is-adf}
adf_test(ts_is) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para Índice de Salarios", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

Los resultados de la prueba se encuentran detallados en la Tabla \@ref(tab:is-kpss).

```{r is-kpss}
kpss_test(ts_is) %>% 
  kable(booktabs = T, caption = "Test KPSS para Índice de Salarios", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Ambos tests concluyen que la serie de Índice de Salarios es _no estacionaria_.

#### Diferenciación

En la Figura \@ref(fig:is) se observa que, al igual que la serie de IPC, el Índice de Salarios tampoco es estacionario. Su media varia a lo largo del tiempo y su función de autocorrelación también decrece lentamente en forma lineal.

Mediante la función `ndiffs` de R, se estima que el número de diferenciaciones necesarias para convertir la serie en estacionaria. El resultado obtenido es `r ndiffs(ts_is)`.

```{r}
is_ndiffs <- ndiffs(ts_is)
is_nsdiffs <- nsdiffs(ts_is)
```

```{r is-diferenciado, fig.cap="Índice de Salarios diferenciado", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_is <- ts_is %>% 
  diff(1, differences=is_ndiffs)

ggtsdisplay(dif_ts_is, 
            main = "Índice de Salarios: Diferenciado una vez")
```

**Test de Estacionariedad: ADF**

Al aplicar el test ADF a la serie diferenciada, el valor de $\tau^{e}$ se encuentra en la zona de rechazo de `H_0`, por lo que se confirma que la serie diferenciada es estacionaria.

```{r is-adf-dif}
adf_test(dif_ts_is) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para Índice de Salarios diferenciado", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

El test KPSS sobre la serie diferenciada concuerda con el test ADF, concluyendo que la serie diferenciada es _estacionaria_.

```{r is-kpss-dif}
kpss_test(dif_ts_is) %>% 
  kable(booktabs = T, caption = "Test KPSS para Índice de Salarios diferenciado", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


### Base Monetaria

#### Analisis de la serie

En la Figura \@ref(fig:bm), se observa que la serie de base monetaria es _no estacionaria_ ya que su media varia a lo largo del tiempo y su función de autocorrelación decrece en forma lineal lentamente.

```{r bm, fig.cap="Base Monetaria", fig.height=5, fig.width=10}
ggtsdisplay(ts_bm, main = 'Base Monetaria')
```

Es posible someter la evidencia gráfica a distintas pruebas estadísticas para ratificar o rectificar lo observado.

**Test de Estacionariedad: ADF**

En la Tabla \@ref(tab:bm-adf) se observa $\tau^{e}$ entre el valor crítico y cero, lo que determina que no hay evidencia para rechazar $H_{0}$ (serie no estacionaria).

```{r bm-adf}
adf_test(ts_bm) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para Base Monetaria", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

Los resultados de la prueba se encuentran detallados en la Tabla \@ref(tab:bm-kpss).

```{r bm-kpss}
kpss_test(ts_bm) %>% 
  kable(booktabs = T, caption = "Test KPSS para Base Monetaria", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En este caso el p-value es menor al grado de significación 0.05, por lo que se rechaza $H_0$.

En conclusión, ambos tests determinan que la serie de IPC es _no estacionaria_.

#### Diferenciación

```{r}
bm_ndiffs <- ndiffs(ts_bm)
```

Mediante la función `ndiffs` de R, se estima que el numero de diferenciaciones necesarias para convertir a la serie ___ en estacionaria (`r bm_ndiffs` veces).

La Figura \@ref(fig:bm-diferenciado) muestra el indice de precios al consumidor diferenciado.

```{r bm-diferenciado, fig.cap="Base Monetaria diferenciada", fig.height=5, fig.width=10}
dif_ts_bm <- ts_bm %>%
  diff(lag = 1, differences = bm_ndiffs)

ggtsdisplay(dif_ts_bm, 
            main = "Base Monetaria: Diferenciada una vez")
```    

**Test de Estacionariedad: ADF**

Se corrobora que la serie de --- diferenciada es estacionaria mediante el test Dickey-Fuller aumentado (Tabla \@ref(tab:bm-dif-adf)). El valor de $\tau^{e}$ se encuentra dentro de la zona de rechazo, por lo que se concluye que se rechaza $H_0$.

```{r bm-dif-adf}
adf_test(dif_ts_bm) %>% 
  kable(booktabs = T, caption = "Test de ADF para Base Monetaria diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

El test KPSS coincide con ADF. El p-value es mayor al grado de significación de 0.05, por lo que no se rechaza la hipótesis nula de estacionariedad.

```{r bm-dif-kpss}
kpss_test(dif_ts_bm) %>% 
  kable(booktabs = T, caption = "Test KPSS para Base Monetaria diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Se confirma entonces que la serie diferenciada es _estacionaria_.


```{r}
dif_ts_bm <- window(dif_ts_bm, start = index(dif_ts_ipc)[1])
var_data <- cbind(dif_ts_bm, dif_ts_ipc)
```

### Modelado

Se utilizan distintos criterios de información para decidir el número de retardos a incluir.

```{r var-selection}
information_criteria <- VARselect(var_data, lag.max = 12, type = "const")

information_criteria$selection %>% 
  t %>%
  kable(booktabs = T, caption = "Criterios de selección", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


En la tabla \@ref(tab:var-selection), todos sugieren que el uso de p = 1 es apropiado para estimar el modelo.

```{r}
var_model <- VAR(var_data, p = 1, type = "const", season = NULL, exog = NULL) 
```

El resumen del modelo se incluye en el [Apendice](#ipc-bm-modelo-var)).

### Análisis de diagnóstico

Para evaluar el ajuste del modelo se ejecutan algunas pruebas de diagnostico sobre los residuos del modelo.

```{r portmanteau-test}
portmanteau_test <- serial.test(var_model, lags.pt = 12, type = "PT.asymptotic")

portmanteau_test_result <- data.frame(portmanteau_test$serial$statistic,
                                      portmanteau_test$serial$parameter,
                                      portmanteau_test$serial$p.value) 
colnames(portmanteau_test_result) <- c("Estadístico", "Parámetro", "P Value")
rownames(portmanteau_test_result) <- NULL

portmanteau_test_result%>%
  kable(booktabs = T, caption = "Test de Portmanteau para la correlación de residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


Con la prueba de Portmanteau se revisa correlación. Un p-value mayor al 5% indica la ausencia de correlación, no se rechaza la hipótesis nula.

Es posible tener evidencia de homocedasticidad utilizando la prueba Multiplicador de Lagrange, para efectos ARCH.

```{r arch}
arch_test <- arch.test(var_model, lags.multi = 12, multivariate.only = TRUE)

arch_test <- data.frame(arch_test$arch.mul$statistic,
                        arch_test$arch.mul$parameter,
                        arch_test$arch.mul$p.value) 
colnames(arch_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(arch_test) <- NULL

arch_test%>%
  kable(booktabs = T, caption = "Test ARCH para la homocedasticidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En la Tabla \@ref(tab:arch) so observa un p-value por encima del valor crítico lo que no brinda evidencia suficiente para rechazar la hipótesis nula de homocedasticidad.


Se utiliza la prueba de Jarque-Bera para comprobar si una muestra de datos tiene la asimetría y la curtosis de una distribución normal.

```{r jb}
# TODO: y si aca solo mostramos jarque bera?

normality_test <- normality.test(var_model)

e <- c(normality_test$jb.mul$JB$statistic,
       normality_test$jb.mul$Skewness$statistic,
       normality_test$jb.mul$Kurtosis$statistic)
p <- c(normality_test$jb.mul$JB$parameter,
       normality_test$jb.mul$Skewness$parameter,
       normality_test$jb.mul$Kurtosis$parameter)
pv <- c(normality_test$jb.mul$JB$p.value,
        normality_test$jb.mul$Skewness$p.value,
        normality_test$jb.mul$Kurtosis$p.value)

normality_test <- data.frame(e, p, pv)
colnames(normality_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(normality_test) <- c("Jarque-Bera", "Asimetría", "Curtosis")

normality_test %>%
  kable(booktabs = T, caption = "Normalidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


```{r}
# TODO: nos conviene meternos en este lio? yo lo borraria

resid <- residuals(var_model)
shapiro_test_bm <- shapiro.test(resid[, 1])
shapiro_test_bm_sin_37 <- shapiro.test(resid[-c(37), 1])
shapiro_test_ipc <- shapiro.test(resid[, 2])
```

Los resultados resumidos en la Tabla \@ref(tab:jb) no muestran residuos distribuidos normalmente. Si se analizan los generados por cada ecuación por separado, la prueba de Shapiro-Wilk (p-value igual a `r shapiro_test_bm$p.value`) para el índice de precios señala normalidad, mientras que para la base monetaria no (p-value igual a `r shapiro_test_ipc$p.value`).

De revisar la Figura \@ref(fig:ipc-vs-is) se observa un valor atípico para el mes de marzo de 2020, eliminando esta lectura se obtiene un p-value igual a `r shapiro_test_bm_sin_37$p.value` observando normalidad.

### Causalidad e Impulso Respuesta

En este punto es posible probar la causalidad de Granger, donde la hipótesis nula de que no hay causalidad se descarta en ambas direcciones

```{r}
cause_bm <- causality(var_model, cause = "dif_ts_bm")

bm_granger <- data.frame(cause_bm$Granger$method, 
                         cause_bm$Granger$p.value)

colnames(bm_granger) <- c("Método", "P-Value")

bm_granger %>%
  kable(booktabs = T, caption = "Causalidad de Grange: Base Monetaria", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

```{r}
cause_ipc <- causality(var_model, cause = "dif_ts_ipc")

ipc_granger <- data.frame(cause_ipc$Granger$method,
                          cause_ipc$Granger$p.value)

colnames(ipc_granger) <- c("Método", "P-Value")

ipc_granger %>%
  kable(booktabs = T, caption = "Causalidad de Grange: IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Generar funciones de respuesta de impulso para describir la respuesta de la producción a un shock de desempleo

```{r}
irf_bm <- irf(var_model, 
              impulse = "dif_ts_bm", 
              response = "dif_ts_ipc",  
              n.ahead = 11)

irf_bm_data <- data.frame(irf_bm$irf$dif_ts_bm[ ,1],
                          irf_bm$Lower$dif_ts_bm[ ,1],
                          irf_bm$Upper$dif_ts_bm[ ,1], 
                          0:11)
colnames(irf_bm_data) <- c('irf', 'lower', 'upper', 'lags')

irf_ipc <- irf(var_model,
               impulse = "dif_ts_ipc",
               response = "dif_ts_bm",
               n.ahead = 11)

irf_ipc_data <- data.frame(irf_ipc$irf$dif_ts_ipc[ ,1],
                           irf_ipc$Lower$dif_ts_ipc[ ,1],
                           irf_ipc$Upper$dif_ts_ipc[ ,1], 
                           0:11)
colnames(irf_ipc_data) <- c('irf', 'lower', 'upper', 'lags')
```

```{r irf-base-monetaria, fig.cap="Base Monetaria: Impulso Respuesta", fig.height=4, fig.width=10}
irf_bm_data %>%
  ggplot(aes(lags, irf)) +
  geom_line(aes(y = upper), colour = 'lightblue2') +
  geom_line(aes(y = lower), colour = 'lightblue')+
  geom_line(aes(y = irf))+
  geom_ribbon(aes(x=lags, ymax=upper, ymin=lower), fill="lightblue", alpha=.1) +
  xlab("") + ylab("Base Monetaria") + ggtitle("Base Monetaria: Impulso Respuesta") +
  theme(axis.text.x=element_blank()) +
  geom_line(colour = 'black')
```

```{r irf-ipc, fig.cap="IPC: Impulso Respuesta", fig.height=4, fig.width=10}
irf_ipc_data %>%
  ggplot(aes(lags, irf)) +
  geom_line(aes(y = upper), colour = 'lightblue2') +
  geom_line(aes(y = lower), colour = 'lightblue')+
  geom_line(aes(y = irf))+
  geom_ribbon(aes(x=lags, ymax=upper, ymin=lower), fill="lightblue", alpha=.1) +
  xlab("") + ylab("Índice de Precio al Consumidor") + ggtitle("IPC: Impulso Respuesta") +
  theme(axis.text.x=element_blank()) +
  geom_line(colour = 'black')
```

\newpage

# Conclusiones

TODO: ALGO

\newpage

# Referencias bibliográficas

<div id="refs"></div>

\newpage

# Apéndices

## Modelo $VAR$ con retardo 1 para IPC y BM {#ipc-bm-modelo-var}

```{r}
summary(var_model)
```
