---
title:  | 
  Trabajo Práctico Final
subtitle: |
  Análisis de Series Temporales
      
  Maestría en Explotación de Datos y Gestión del Conocimiento
author: |
  Layla Scheli, Franco Lianza, Lucio Scalzo, Ignacio Mujica, Alexis Walker
date: |
  `r format(Sys.time(), '%d %B %Y')`
bibliography: bibliografia.bib
biblio-style: "apa"
link-citations: true

header-includes:
- \usepackage{titling}
- \usepackage{floatrow}

- \renewcommand{\figurename}{Fig.}
- \renewcommand{\contentsname}{Índice}
- \renewcommand{\tablename}{Tabla}

- \pretitle{
      \begin{center}
      \thispagestyle{empty}
      \includegraphics[width=2in,height=2in]{logo.png}\LARGE\\
      \vskip 12em
  }
- \posttitle{\end{center}}

- \preauthor{
      \begin{center}
      \vskip 26em
  }
- \postauthor{\end{center}}
  
- \predate{\begin{center}}
- \postdate{
    \end{center}
    \vskip 4em
  }

output: 
  bookdown::pdf_document2: default

toc: yes
toc-depth: 4
---

\thispagestyle{empty}
\newpage

\thispagestyle{empty}

\abstract

\setlength{\parskip}{0.5em}
\setlength{\parindent}{0em}


\noindent El presente trabajo tiene por objetivo estudiar la relación entre tres variables económicas fundamentales, el Indice de precios al Consumidor (IPC), el Índice de Salarios y la Base Monetaria.

Los primeros dos son considerados fundamentales para el desarrollo de un país ya que conllevan, en la relación entre ambos, dos efectos antagónicos según se comporten. 

Por un lado, cómo evoluciona en nivel de vida de la población. Si los salarios se incrementan en mayor proporción que los bienes y servicios, consiguientemente se mejora el bienestar además del incremento de la producción ocasionando mayor demanda.

Por otro, si los indicadores de incremento de bienes y servicios crecen a mayor ritmo que los salarios, disminuye el bienestar de la masa asalariada.

Como resultado de este proceso inflacionario (elemento que sugiere incluir en el análisis la Base Monetaria) y de baja demanda interna hay que mencionar que esto perjudica a los sectores productivos internos. 

Las causas que originan el fenómeno de inflación no serán tratadas por lo complejo y extenso que es el tema. Se simplifica solo evaluando la posible relación con la creación de moneda.

\newpage

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

```{r, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	fig.pos = "H",
	warning = FALSE,
	out.extra = ""
)
```

```{r setup, include=FALSE}
paquetes <- c("readr", "tidyverse", "forecast", "gridExtra",
              "tseries", "tsibble", "kableExtra", "vars", "prophet")

instalados <- paquetes %in% rownames(installed.packages())

if (any(instalados == FALSE)) {
  install.packages(paquetes[!instalados])
}

invisible(lapply(paquetes, library, character.only = TRUE))

theme_set(theme_bw())
```

```{r}
kpss_test <- function(ts){
  kppst <- kpss.test(ts)
  df <- data.frame(kppst$statistic, kppst$p.value, kppst$parameter)
  colnames(df) <- c("Estadístico", "P-Value", "Lag")
  rownames(df) <- NULL
  
  return(df)
}

adf_test <- function(ts){
  ur_df <- ur.df(ts, selectlags = "AIC", type = "trend")
  df <- cbind(as.data.frame(t(ur_df@teststat)), ur_df@cval)
  colnames(df)[1] <- "Estadístico"

  return(df)
}

shapiro_wilk_normality_test <- function(residuos){
  sw <- shapiro.test(residuos)
  df <- data.frame(sw$statistic, sw$p.value)
  colnames(df) <- c("Estadístico", "P-Value")
  rownames(df) <- NULL
  
  return(df)
}
```


```{r}
raw_data <- read_csv(
  file = "https://docs.google.com/uc?id=16we_OjrEZxBUwaQKOh3QAoW5YwfcEg1E",
  col_types = cols(fecha = col_date(format = "%d/%m/%Y")))
```



```{r}
ipc <- raw_data %>%
  dplyr::select(fecha, indice_precios_consumidor_acumulada)

is <- raw_data %>%
  dplyr::select(fecha, indice_salarios_acumulada)

bm <- raw_data %>%
  dplyr::select(fecha, variacion_base_monetaria_acumulada)


ts_ipc <- ipc$indice_precios_consumidor_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_is <- is$indice_salarios_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))

ts_bm <- bm$variacion_base_monetaria_acumulada %>%
  ts(frequency = 12, start = c(2016, 12))
```


# Introducción

Las series de tiempo son el resultado de observar valores de una variable aleatoria a lo largo del tiempo en intervalos iguales o desiguales. En el análisis de las series temporales se utilizan métodos que permiten interpretarlas y extraer información sobre las relaciones entre los datos de la serie u otras series. 

Según @mochon, _“La inflación es el crecimiento generalizado y continuo de los precios de los bienes y los servicios”_ (p. 496), y el índice de precios al consumidor (IPC) representa el costo de la canasta de bienes y servicios consumidos por la economía local.

El  fenómeno  de la inflación se produce por múltiples causas. Las teorías tradicionales se pueden resumir en: inflación de demanda, que se produce cuando los gastos superan la capacidad de producción de la economía, por causas monetarias, cuando se incrementa la emisión monetaria, la inflación de costos, cuando los precios suben por grupos económicos de presión y la inflación estructural, que es la que se origina debido a los problemas estructurales de las economías en vías de desarrollo.

La percepción individual sugiere que los motivos, en la coyuntura actual, son variados: especulación, emisión desmedida, presión por devaluación, bajas exportaciones, monopolios formadores de precios, elevado gasto público, mercado laboral altamente regulado, etc.

Analizar como evolucionan conjuntamente en el tiempo el Índice de precios al consumidor y el Índice de salarios puede ayudar a clarificar los problemas y soluciones posibles.

Además, esta comparativa muestra cómo se comporta el poder adquisitivo de un empleado. Es posible determinar si se recompone conforme aumentan los precios, acompaña o se abre una brecha que da cuenta de su disminución.

```{r ipc-vs-is-vs-bm, fig.cap="IPC vs IS vs BM", fig.height=4, fig.width=10}
autoplot(ts_ipc, series = 'Índice de Precios al Consumidor') +
  autolayer(ts_is, series = 'Índice de Salarios') +
  autolayer(ts_bm, series = 'Base Monetaria') +
  ggtitle('Índice de Precios al Consumidor, Índice de Salarios acumulados y Base Monetaria',
          subtitle = 'Con base Diciembre 2016') +
  ylab('% de cambio acumulado') +
  xlab('Tiempo')
```

La información fue extraída de la página oficial del Instituto Nacional de Estadística y Censos - INDEC Argentina:

- Índice de precios al consumidor
- Índice de salarios
- Base monetaria

Se considera la variación mensual acumulada estableciendo a Diciembre 2016 como el 100% y se pretende predecir los cambios de las series para Enero 2022.

\newpage

# Marco Teórico

Los modelos de vectores autorregresivos son validos para series de tiempo que son _estacionarias_. Se define que una serie es estacionaria de orden 2 cuando sus segundos momentos son constantes a lo largo del tiempo. Es decir, cuando su media y varianza se mantienen constantes.

Por lo contrario, una serie es _no estacionaria_ cuando la tendencia y/o la variabilidad cambian a lo largo del tiempo.

El presente trabajo práctico tiene como objetivo el análisis de la estacionariedad de las series presentadas y su modelado mediante modelos VAR y Prophet.

## Tests de estacionariedad

La estacionariedad puede ser puesta a prueba mediante diferentes tests. Se detallan los dos a utilizar.

### Dickey-Fuller Aumentado

En la ecuación de Dickey-Fuller aumentada \@ref(eq:df):

\begin{equation}
\nabla Y_{t} =  a_{0} + a_{1} t + (\phi_{1} - 1) Y_{t-1} + \epsilon_{t}
(\#eq:df)
\end{equation}

Se pone a prueba el coeficiente que acompaña al rezago del período anterior: $(\phi_{1} - 1)$.

El estadístico de este test es:

\begin{equation}
\tau^{e} = \frac{\hat{\phi_{1}} - \phi_{1}}{\sigma(\hat{\phi_{1}})}
\end{equation}

Se plantea la regla de decisión:

> Si $\tau \leq \tau^{e} < 0 \Rightarrow$ No Rechazar $H_{0}$

> Si $\tau^{e} < \tau \Rightarrow$ Rechazar $H_{0}$

Como se explica en @pena, la hipótesis nula establece que la raíz mayor de un $AR(p+1)$ es igual a uno, por lo que el proceso es no estacionario.

### Kwiatkowski-Phillips-Schmidt-Shin

@kpss definen otra prueba para raíces unitarias en la cual la hipótesis nula es contraria al test ADF, es decir, plantea que la serie temporal observable es estacionaria.

## Transformaciones para estabilizar la media y la varianza

Según lo expresado en @pena, la identificación de las estructuras no estacionarias consiste en detectar qué transformaciones hay que aplicar para conseguir un proceso con media y varianza constante. 

En particular, consiste en determinar si es necesario: transformar la serie para que tenga varianza constante y/o diferenciarla para darle una media constante.

Por un lado, las transformaciones de potencia de Box-Cox son una forma general que permiten convertir el proceso original en un proceso condicionalmente homocedástico.

Por otro, como se puede asumir que la tendencia de una serie en el instante $t$ es muy próxima a la del instante $t-1$, se puede formular una nueva serie de la manera $Y_t = y_t - y_{t-1}$. Este proceso se define como _diferenciación_ y permite transformar una serie no estacionaria a estacionaria.

## Vectores autoregresivos

El modelado ARIMA está limitado por su incapacidad para capturar interrelaciones dinámicas entre variables de interés. La generalización directa del modelo ARMA estacionario a la forma multivariante conduce a un modelo vectorial (@var).

Por variable en el sistema, existe una ecuación, cuyo lado derecho incluye una constante y retrasos de todas las variables presentes. 

Para mantenerlo simple, se presenta un modelo VAR de dos variables con retraso igual a 1 ($p = 1$):

\begin{equation}
  y_{1, t} = c_{1} + \phi_{11, 1} y_{1, t-1} +  \phi_{12, 1} y_{2, t-1} + \epsilon_{1, t}
  (\#eq:varyuno)
\end{equation}

\begin{equation}
  y_{2, t} = c_{2} + \phi_{21, 1} y_{1, t-1} +  \phi_{22, 1} y_{2, t-1} + \epsilon_{2, t}
  (\#eq:varydos)
\end{equation}

Donde $\epsilon_{1, t}$ y $\epsilon_{2, t}$ \~ $N(0,\sigma_{y})$ y no están autocorrelacionados. $y_{1, t}$ y $y_{2, t}$ son estacionarias. El coeficiente $\phi_{ii, p}$ captura la influencia del _lag_ $p$ de la variable $y_{i}$ sobre si misma. Mientras que $\phi_{ij, p}$ determina el peso del _lag_ $p$ de la variable $y_{j}$ sobre $y_{i}$.


usar fpe: https://homepage.univie.ac.at/robert.kunst/pres07_var_abdgunyan.pdf

Final Prediction Error Criterion
The Final Prediction Error Criterion (FPE) estimates the model-fitting error when you use the model to predict new outputs. For the FPE, an optimal model is the one that minimizes the following equation:

[1] Ljung, L. System Identification: Theory for the User, Upper Saddle River, NJ, Prentice-Hall PTR, 1999. See sections 7.4 and 16.4.



You want to choose a model that minimizes the FPE, which represents a balance between the number of parameters and the explained variation.

## Prophet 

Es un procedimiento para pronosticar datos de series temporales basado en un modelo aditivo donde las tendencias no lineales se ajustan a la estacionalidad anual, semanal y diaria, además de los efectos de las vacaciones. 

Resistente a datos faltantes, valores atípicos y cambios de tendencia. 

\newpage

# Análisis de Resultados

## Analisis de la series {#analisis}

### Índice de Precios al Consumidor

En la Figura \@ref(fig:ipc), se observa que la serie IPC es _no estacionaria_ ya que su media varía a lo largo del tiempo y su función de autocorrelación decrece lentamente en forma lineal.

```{r ipc, fig.cap="Índice de precios al consumidor", fig.height=5, fig.width=10}
ggtsdisplay(ts_ipc, main = 'Índice de precios al consumidor')
```

Es posible someter la evidencia gráfica a distintas pruebas estadísticas para ratificar o rectificar lo observado.

**Test de Estacionariedad: ADF**

En la Tabla \@ref(tab:ipc-adf) se observa $\tau^{e}$ entre el valor crítico y cero, lo que determina que no hay evidencia para rechazar $H_{0}$ (serie no estacionaria).

```{r ipc-adf}
adf_test(ts_ipc) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

Los resultados de la prueba se encuentran detallados en la Tabla \@ref(tab:ipc-kpss).

```{r ipc-kpss}
kpss_test(ts_ipc) %>% 
  kable(booktabs = T, caption = "Test KPSS para IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En este caso el p-value es menor al grado de significación 0.05, por lo que se rechaza $H_0$. A diferencia de la prueba anterior, en este caso la hipótesis nula plantea estacionariedad.

En conclusión, ambos tests determinan que la serie IPC es _no estacionaria_.

### Índice de Salarios

La Figura \@ref(fig:is) muestra la serie de Índice de Salarios con evidencia gráfica de _no estacionariedad_.

```{r is, fig.cap="Índice de Salarios", fig.height=5, fig.width=10, fig.pos="H"}
ggtsdisplay(ts_is, main = "Índice de Salarios")
```

**Test de Estacionariedad: ADF**

En la Tabla \@ref(tab:is-adf) se observa $\tau^{e}$ entre el valor crítico y cero, lo que determina que no hay evidencia para rechazar $H_{0}$.

```{r is-adf}
adf_test(ts_is) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para Índice de Salarios", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

Los resultados de la prueba se encuentran detallados en la Tabla \@ref(tab:is-kpss).

```{r is-kpss}
kpss_test(ts_is) %>% 
  kable(booktabs = T, caption = "Test KPSS para Índice de Salarios", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Ambos tests concluyen que la serie de Índice de Salarios es _no estacionaria_.

### Base Monetaria

La Figura \@ref(fig:bm) muestra la serie de Base Monetaria que, al igual que las anteriores presenta comportamientos _no estacionarios_.

```{r bm, fig.cap="Base Monetaria", fig.height=5, fig.width=10}
ggtsdisplay(ts_bm, main = 'Base Monetaria')
```

**Test de Estacionariedad: ADF**

En la Tabla \@ref(tab:bm-adf) se observa $\tau^{e}$ entre el valor crítico y cero, lo que determina que no hay evidencia para rechazar $H_{0}$.

```{r bm-adf}
adf_test(ts_bm) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para Base Monetaria", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

Los resultados de la prueba se encuentran detallados en la Tabla \@ref(tab:bm-kpss).

```{r bm-kpss}
kpss_test(ts_bm) %>% 
  kable(booktabs = T, caption = "Test KPSS para Base Monetaria", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Ambos tests concluyen estadísticamente la _no estacionariedad_ de la serie, coherente con lo que las funciones de autocorrelación hacían suponer.

## Vectores Autoregresivos

Bajo la sospecha de la existencia de una interacción simultánea entre los grupos de variables bajo análisis, se plantea un modelo de ecuaciones donde las variables explicativas se componen del rezago de cada una de las incorporadas.

Debido a que un modelo VAR estructural se basa, entre otras cosas, en la estacionariedad de las series, la primera instancia del desarrollo es obtener transformaciones de los datos originales (ya concluida la falta de esta propiedad en la sección [Analisis de la series](#analisis)) para cumplir con la precondición.  

### Diferenciación

#### Índice de Precios al Consumidor

```{r}
ipc_ndiffs <- ndiffs(ts_ipc)
```

Mediante la función `ndiffs` de R, se estima que el numero de diferenciaciones necesarias para convertir a la serie IPC en estacionaria (`r ipc_ndiffs` veces).

La Figura \@ref(fig:ipc-diferenciado) muestra el Índice de Precios al Consumidor diferenciado.

```{r ipc-diferenciado, fig.cap="Índice de precio al consumidor diferenciado", fig.height=5, fig.width=10}
dif_ts_ipc <- ts_ipc %>%
  diff(lag = 1, differences = ipc_ndiffs)

ggtsdisplay(dif_ts_ipc, 
            main = "Índice de precios al consumidor: Diferenciado dos veces")
```    

**Test de Estacionariedad: ADF**

Se corrobora que la serie IPC diferenciada es estacionaria mediante el test Dickey-Fuller aumentado (Tabla \@ref(tab:ipc-dif-adf)). El valor de $\tau^{e}$ se encuentra dentro de la zona de rechazo, por lo que se concluye la no aceptación de $H_0$.

```{r ipc-dif-adf}
adf_test(dif_ts_ipc) %>% 
  kable(booktabs = T, caption = "Test de ADF para IPC diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

El test KPSS coincide con ADF. El p-value es mayor al grado de significación de 0.05, por lo que no se rechaza la hipótesis nula de estacionariedad.

```{r ipc-dif-kpss}
kpss_test(dif_ts_ipc) %>% 
  kable(booktabs = T, caption = "Test KPSS para IPC diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Se confirma entonces que la serie diferenciada es _estacionaria_.


#### Índice de Salarios

```{r}
is_ndiffs <- ndiffs(ts_is)
#is_nsdiffs <- nsdiffs(ts_is)
```

En la Figura \@ref(fig:is) se observa que, al igual que la serie IPC, el Índice de Salarios tampoco es estacionario.

Mediante la función `ndiffs` de R, se estima que el número de diferenciaciones necesarias para convertir la serie en estacionaria. El resultado obtenido es `r is_ndiffs`.

```{r is-diferenciado, fig.cap="Índice de Salarios diferenciado", fig.height=5, fig.width=10, fig.pos="H"}
dif_ts_is <- ts_is %>% 
  diff(1, differences=is_ndiffs)

ggtsdisplay(dif_ts_is, 
            main = "Índice de Salarios: Diferenciado una vez")
```

**Test de Estacionariedad: ADF**

Al aplicar el test ADF a la serie diferenciada, el valor de $\tau^{e}$ se encuentra en la zona de rechazo de $H_0$, por lo que se confirma que la serie diferenciada es estacionaria.

```{r is-adf-dif}
adf_test(dif_ts_is) %>% 
  kable(booktabs = T, caption = "Prueba de ADF para Índice de Salarios diferenciado", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

El test KPSS concuerda con el test ADF, concluyendo que la serie diferenciada es _estacionaria_.

```{r is-kpss-dif}
kpss_test(dif_ts_is) %>% 
  kable(booktabs = T, caption = "Test KPSS para Índice de Salarios diferenciado", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

#### Base Monetaria

```{r}
bm_ndiffs <- ndiffs(ts_bm)
```

Mediante la función `ndiffs` de R, se estima que el numero de diferenciaciones necesarias para convertir a la serie Base Monetaria en estacionaria (`r bm_ndiffs` veces).

La Figura \@ref(fig:bm-diferenciado) muestran los valores diferenciado.

```{r bm-diferenciado, fig.cap="Base Monetaria diferenciada", fig.height=5, fig.width=10}
dif_ts_bm <- ts_bm %>%
  diff(lag = 1, differences = bm_ndiffs)

ggtsdisplay(dif_ts_bm, 
            main = "Base Monetaria: Diferenciada una vez")
```    

**Test de Estacionariedad: ADF**

Se corrobora que la serie diferenciada es estacionaria mediante el test Dickey-Fuller aumentado (Tabla \@ref(tab:bm-dif-adf)). El valor de $\tau^{e}$ se encuentra dentro de la zona de rechazo de la hipótesis nula.

```{r bm-dif-adf}
adf_test(dif_ts_bm) %>% 
  kable(booktabs = T, caption = "Test de ADF para Base Monetaria diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

**Test de Estacionariedad: KPSS**

El test KPSS coincide con ADF. El p-value es mayor al grado de significación de 0.05, por lo que no se rechaza la hipótesis nula.

```{r bm-dif-kpss}
kpss_test(dif_ts_bm) %>% 
  kable(booktabs = T, caption = "Test KPSS para Base Monetaria diferenciada", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Se confirma entonces que la serie diferenciada es _estacionaria_.

```{r}
dif_ts_bm <- window(dif_ts_bm, start = index(dif_ts_ipc)[1])
dif_ts_is <- window(dif_ts_is, start = index(dif_ts_ipc)[1])
```

```{r}
train_ipc <- window(dif_ts_ipc, end = c(2021, 04))
test_ipc <- window(dif_ts_ipc, start = c(2021, 05))

train_is <- window(dif_ts_is, end = c(2021, 04))
test_is <- window(dif_ts_is, start = c(2021, 05))

train_bm <- window(dif_ts_bm, end = c(2021, 04))
test_bm <- window(dif_ts_bm, start = c(2021, 05))
```

```{r}
ipc_is <- cbind(train_ipc, train_is)
ipc_bm <- cbind(train_ipc, train_bm)
is_bm <- cbind(train_is, train_bm)
```

```{r}
# todo <- cbind(train_ipc, train_is, train_bm)
# information_criteria <- VARselect(todo, lag.max = 11, type = "const")
# todo_model <- VAR(todo, p = 10, type = "const", season = NULL, exog = NULL)
# 
# var_forecast <- forecast(todo_model, h = 3)
# 
# 
# test_bm
# var_forecast$forecast$train_bm
# window(ts_bm, start = start(test_bm))
# 
# 
# var_forecast <- adjust_forecast(train_bm, window(ts_bm, end = end(train_bm)), var_forecast, "train_bm", bm_ndiffs)
# 
# autoplot(window(ts_bm, end = end(train_bm)),
#          series = "train") +
#   autolayer(var_forecast$forecast$train_bm,
#             series = "Pronostico",
#             alpha = 0.5) +
#     autolayer(window(ts_bm, start = start(test_bm)),
#             series = "test") +
#   
#   labs(x = "Tiempo", y = "Porcentaje Acumulado") +
#   ggtitle("Series con sus pronosticos")
```

### Modelado

Con el objeto principal de analizar causalidad entre series se proponen modelos agrupando de a pares los datos que se utilizan.

Se calculan y muestran distintos criterios de selección para determinar el modelo que mejor ajusta, sin embargo se trabaja con el *Error de Predicción Final* (o FPE de su denominación en inglés) para determinar que retardo utilizar.

### Modelo: Índice de Precios al Consumidor y Base Monetaria

#### Selección

```{r var-selection-ipc-bm}
information_criteria <- VARselect(ipc_bm, lag.max = 12, type = "const")

information_criteria$selection %>% 
  t %>%
  kable(booktabs = T, caption = "Criterios de selección", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7) %>%
  column_spec(4, color = "red")

lags = information_criteria$selection[4]
```


En la tabla \@ref(tab:var-selection-ipc-bm), se sugieren que el uso de retardo igual a `r lags` es apropiado para estimar el modelo. El resumen del modelo se incluye en el [Apendice](#ipc-bm-modelo-var).

```{r}
ipc_bm_model <- VAR(ipc_bm, p = lags, type = "const", season = NULL, exog = NULL) 
```

#### Análisis de diagnóstico

Para evaluar el ajuste del modelo se ejecutan algunas pruebas de diagnostico sobre los residuos del modelo.

```{r portmanteau-test-ipc-bm}
portmanteau_test <- serial.test(ipc_bm_model, lags.pt = 12, type = "PT.asymptotic")

portmanteau_test_result <- data.frame(portmanteau_test$serial$statistic,
                                      portmanteau_test$serial$parameter,
                                      portmanteau_test$serial$p.value) 
colnames(portmanteau_test_result) <- c("Estadístico", "Parámetro", "P Value")
rownames(portmanteau_test_result) <- NULL

portmanteau_test_result%>%
  kable(booktabs = T, caption = "Test de Portmanteau para la correlación de residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


Con la prueba de Portmanteau se revisa correlación. Según la Tabla \@ref(tab:portmanteau-test-ipc-bm), un p-value mayor al 5% indica la ausencia de correlación, no se rechaza la hipótesis nula de correlación.

Es posible tener evidencia de homocedasticidad utilizando la prueba Multiplicador de Lagrange, para efectos ARCH.

```{r arch-ipc-bm}
arch_test <- arch.test(ipc_bm_model, lags.multi = 12, multivariate.only = TRUE)

arch_test <- data.frame(arch_test$arch.mul$statistic,
                        arch_test$arch.mul$parameter,
                        arch_test$arch.mul$p.value) 
colnames(arch_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(arch_test) <- NULL

arch_test%>%
  kable(booktabs = T, caption = "Test ARCH para la homocedasticidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En la Tabla \@ref(tab:arch-ipc-bm) se observa un p-value por encima del valor crítico lo que no brinda evidencia suficiente para rechazar la hipótesis nula de homocedasticidad.

Se utiliza la prueba de Jarque-Bera para comprobar si una muestra de datos tiene la asimetría y la curtosis de una distribución normal.

```{r jb-ipc-bm}
# TODO: y si aca solo mostramos jarque bera?

normality_test <- normality.test(ipc_bm_model)

e <- c(normality_test$jb.mul$JB$statistic,
       normality_test$jb.mul$Skewness$statistic,
       normality_test$jb.mul$Kurtosis$statistic)
p <- c(normality_test$jb.mul$JB$parameter,
       normality_test$jb.mul$Skewness$parameter,
       normality_test$jb.mul$Kurtosis$parameter)
pv <- c(normality_test$jb.mul$JB$p.value,
        normality_test$jb.mul$Skewness$p.value,
        normality_test$jb.mul$Kurtosis$p.value)

normality_test <- data.frame(e, p, pv)
colnames(normality_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(normality_test) <- c("Jarque-Bera", "Asimetría", "Curtosis")

normality_test %>%
  kable(booktabs = T, caption = "Normalidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


```{r}
# TODO: nos conviene meternos en este lio? yo lo borraria

resid <- residuals(ipc_bm_model)
shapiro_test_ipc <- shapiro.test(resid[, 1])
shapiro_test_bm <- shapiro.test(resid[, 2])
shapiro_test_bm_sin_37 <- shapiro.test(resid[-c(37), 2])

```

Los resultados resumidos en la Tabla \@ref(tab:jb-ipc-bm) no muestran residuos distribuidos normalmente. Si se analizan los generados por cada ecuación por separado, la prueba de Shapiro-Wilk (p-value igual a `r shapiro_test_ipc$p.value`) para el índice de precios señala normalidad, mientras que para la base monetaria no (p-value igual a `r shapiro_test_bm$p.value`).

De revisar la Figura \@ref(fig:ipc-vs-is-vs-bm) se observa un valor atípico para el mes de marzo de 2020, eliminando esta lectura se obtiene un p-value igual a `r shapiro_test_bm_sin_37$p.value` observando normalidad.

#### Causalidad e Impulso Respuesta

En este punto es posible probar la causalidad de Granger.

```{r granger-ipc-bm}
cause_bm <- causality(ipc_bm_model, cause = "train_bm")
cause_ipc <- causality(ipc_bm_model, cause = "train_ipc")


granger <- data.frame(c(cause_bm$Granger$method, cause_ipc$Granger$method), 
                      c(cause_bm$Granger$p.value, cause_ipc$Granger$p.value))

colnames(granger) <- c("Método", "P-Value")

granger %>%
  kable(booktabs = T, caption = "Causalidad de Grange: Base Monetaria e IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7) %>%
  column_spec(2, color = ifelse(granger[,2] < 0.05, "red", "black"))
```

En la Tabla \@ref(tab:granger-ipc-bm) se observa evidencia que el Índice de Precios al Consumidor es causa de la Base Monetaria.

Se genera la función Impulso-Respuesta para describir la respuesta de la Base Monetaria a un _shock_ de IPC.

```{r}
irf_ipc <- irf(ipc_bm_model,
               impulse = "train_ipc",
               response = "train_bm",
               n.ahead = 11)

irf_ipc_data <- data.frame(irf_ipc$irf$train_ipc[ ,1],
                           irf_ipc$Lower$train_ipc[ ,1],
                           irf_ipc$Upper$train_ipc[ ,1], 
                           0:11)
colnames(irf_ipc_data) <- c('irf', 'lower', 'upper', 'lags')
```

```{r irf-ipc-bm, fig.cap="Impulso Respuesta: IPC y Base Monetaria", fig.height=4, fig.width=10}
irf_ipc_data %>%
  ggplot(aes(lags, irf)) +
  geom_line(aes(y = upper), colour = 'lightblue2') +
  geom_line(aes(y = lower), colour = 'lightblue')+
  geom_line(aes(y = irf))+
  geom_ribbon(aes(x=lags, ymax=upper, ymin=lower), fill="lightblue", alpha=.1) +
  xlab("") + ylab("Base Monetaria") + ggtitle("Impulso Respuesta: IPC y Base Monetaria") +
  #theme(axis.text.x=element_blank()) +
  geom_line(colour = 'black')
```

En la Figura \@ref(fig:irf-ipc-bm) se identifica que los _shocks_ en IPC no tienen un impacto de largo plazo en la Base Monetaria, su efecto desaparece después de 4 meses. Contribuyen a la variabilidad a corto plazo.

### Modelo: Índice de Precios al Consumidor y Índice de Salarios

#### Selección

```{r var-selection-ipc-is}
information_criteria <- VARselect(ipc_is, lag.max = 12, type = "const")

information_criteria$selection %>% 
  t %>%
  kable(booktabs = T, caption = "Criterios de selección", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7) %>%
  column_spec(4, color = "red")

lags = information_criteria$selection[4]
```

En la tabla \@ref(tab:var-selection-ipc-is), se sugieren que el uso de retardo igual a `r lags` es apropiado para estimar el modelo. El resumen del modelo se incluye en el [Apendice](#ipc-is-modelo-var).

```{r}
ipc_is_model <- VAR(ipc_is, p = lags, type = "const", season = NULL, exog = NULL)
```

#### Análisis de diagnóstico

Para evaluar el ajuste del modelo se ejecutan algunas pruebas de diagnostico sobre los residuos del modelo.

```{r portmanteau-test-ipc-is}
portmanteau_test <- serial.test(ipc_is_model, lags.pt = 12, type = "PT.asymptotic")

portmanteau_test_result <- data.frame(portmanteau_test$serial$statistic,
                                      portmanteau_test$serial$parameter,
                                      portmanteau_test$serial$p.value) 
colnames(portmanteau_test_result) <- c("Estadístico", "Parámetro", "P Value")
rownames(portmanteau_test_result) <- NULL

portmanteau_test_result%>%
  kable(booktabs = T, caption = "Test de Portmanteau para la correlación de residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


Con la prueba de Portmanteau se revisa correlación. Según la Tabla \@ref(tab:portmanteau-test-ipc-is), un p-value mayor al 5% indica la ausencia de correlación, no se rechaza la hipótesis nula de correlación.

Es posible tener evidencia de homocedasticidad utilizando la prueba Multiplicador de Lagrange, para efectos ARCH.

```{r arch-ipc-is}
arch_test <- arch.test(ipc_is_model, lags.multi = 12, multivariate.only = TRUE)

arch_test <- data.frame(arch_test$arch.mul$statistic,
                        arch_test$arch.mul$parameter,
                        arch_test$arch.mul$p.value) 
colnames(arch_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(arch_test) <- NULL

arch_test%>%
  kable(booktabs = T, caption = "Test ARCH para la homocedasticidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En la Tabla \@ref(tab:arch-ipc-is) se observa un p-value por encima del valor crítico lo que no brinda evidencia suficiente para rechazar la hipótesis nula de homocedasticidad.

Se utiliza la prueba de Jarque-Bera para comprobar si una muestra de datos tiene la asimetría y la curtosis de una distribución normal.

```{r jb-ipc-is}
# TODO: y si aca solo mostramos jarque bera?

normality_test <- normality.test(ipc_is_model)

e <- c(normality_test$jb.mul$JB$statistic,
       normality_test$jb.mul$Skewness$statistic,
       normality_test$jb.mul$Kurtosis$statistic)
p <- c(normality_test$jb.mul$JB$parameter,
       normality_test$jb.mul$Skewness$parameter,
       normality_test$jb.mul$Kurtosis$parameter)
pv <- c(normality_test$jb.mul$JB$p.value,
        normality_test$jb.mul$Skewness$p.value,
        normality_test$jb.mul$Kurtosis$p.value)

normality_test <- data.frame(e, p, pv)
colnames(normality_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(normality_test) <- c("Jarque-Bera", "Asimetría", "Curtosis")

normality_test %>%
  kable(booktabs = T, caption = "Normalidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Todos los estadísticos brindan información para reconocer normalidad en la distribución de los errores.

#### Causalidad e Impulso Respuesta

En este punto es posible probar la causalidad de Granger.

```{r granger-ipc-is}
cause_is <- causality(ipc_is_model, cause = "train_is")
cause_ipc <- causality(ipc_is_model, cause = "train_ipc")


granger <- data.frame(c(cause_is$Granger$method, cause_ipc$Granger$method), 
                      c(cause_is$Granger$p.value, cause_ipc$Granger$p.value))

colnames(granger) <- c("Método", "P-Value")

granger %>%
  kable(booktabs = T, caption = "Causalidad de Grange: Índice de Salarios e IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7) %>%
  column_spec(2, color = ifelse(granger[,2] < 0.05, "red", "black"))
```

En la Tabla \@ref(tab:granger-ipc-is) se observa evidencia que el Índice de Salarios es causa del de Precios al Consumidor.

Se genera la función Impulso-Respuesta para describir la respuesta de IPC a un _shock_ en los salarios.

```{r}
irf_is <- irf(ipc_is_model, 
              impulse = "train_is", 
              response = "train_ipc",  
              n.ahead = 15)

irf_is_data <- data.frame(irf_is$irf$train_is[ ,1],
                          irf_is$Lower$train_is[ ,1],
                          irf_is$Upper$train_is[ ,1], 
                          0:15)

colnames(irf_is_data) <- c('irf', 'lower', 'upper', 'lags')
```

```{r irf-is-ipc, fig.cap="Impulso Respuesta: IPC y Índice de Salarios", fig.height=4, fig.width=10}
irf_is_data %>%
  ggplot(aes(lags, irf)) +
  geom_line(aes(y = upper), colour = 'lightblue2') +
  geom_line(aes(y = lower), colour = 'lightblue')+
  geom_line(aes(y = irf))+
  geom_ribbon(aes(x=lags, ymax=upper, ymin=lower), fill="lightblue", alpha=.1) +
  xlab("") + ylab("IPC") + ggtitle("Impulso Respuesta: IPC y Índice de Salarios") +
  #theme(axis.text.x=element_blank()) +
  geom_line(colour = 'black')
```

Gráficamente (Figura \@ref(fig:irf-is-ipc)), los _shocks_ en el Índice de Salarios tienen un impacto a largo plazo en IPC, sus efectos se atenúan pasado el año.

### Modelo: Índice de Salarios y Base Monetaria

#### Selección

```{r var-selection-is-bm}
information_criteria <- VARselect(is_bm, lag.max = 12, type = "const")

information_criteria$selection %>% 
  t %>%
  kable(booktabs = T, caption = "Criterios de selección", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7) %>%
  column_spec(4, color = "red")

lags = information_criteria$selection[4]
```


En la tabla \@ref(tab:var-selection-is-bm), se sugieren que el uso de retardo igual a `r lags` es apropiado para estimar el modelo. El resumen del modelo se incluye en el [Apendice](#is-bm-modelo-var).

```{r}
is_bm_model <- VAR(is_bm, p = lags, type = "const", season = NULL, exog = NULL)
```

#### Análisis de diagnóstico

Para evaluar el ajuste del modelo se ejecutan algunas pruebas de diagnostico sobre los residuos del modelo.

```{r portmanteau-test-is-bm}
portmanteau_test <- serial.test(is_bm_model, lags.pt = 12, type = "PT.asymptotic")

portmanteau_test_result <- data.frame(portmanteau_test$serial$statistic,
                                      portmanteau_test$serial$parameter,
                                      portmanteau_test$serial$p.value) 
colnames(portmanteau_test_result) <- c("Estadístico", "Parámetro", "P Value")
rownames(portmanteau_test_result) <- NULL

portmanteau_test_result%>%
  kable(booktabs = T, caption = "Test de Portmanteau para la correlación de residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```


Con la prueba de Portmanteau se revisa correlación. Según la Tabla \@ref(tab:portmanteau-test-is-bm), un p-value mayor al 5% indica la ausencia de correlación, no se rechaza la hipótesis nula de correlación.

Es posible tener evidencia de homocedasticidad utilizando la prueba Multiplicador de Lagrange, para efectos ARCH.

```{r arch-is-bm}
arch_test <- arch.test(is_bm_model, lags.multi = 12, multivariate.only = TRUE)

arch_test <- data.frame(arch_test$arch.mul$statistic,
                        arch_test$arch.mul$parameter,
                        arch_test$arch.mul$p.value) 
colnames(arch_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(arch_test) <- NULL

arch_test%>%
  kable(booktabs = T, caption = "Test ARCH para la homocedasticidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

En la Tabla \@ref(tab:arch-is-bm) se observa un p-value por encima del valor crítico lo que no brinda evidencia suficiente para rechazar la hipótesis nula de homocedasticidad.

Se utiliza la prueba de Jarque-Bera para comprobar si una muestra de datos tiene la asimetría y la curtosis de una distribución normal.

```{r jb-is-bm}
# TODO: y si aca solo mostramos jarque bera?

normality_test <- normality.test(is_bm_model)

e <- c(normality_test$jb.mul$JB$statistic,
       normality_test$jb.mul$Skewness$statistic,
       normality_test$jb.mul$Kurtosis$statistic)
p <- c(normality_test$jb.mul$JB$parameter,
       normality_test$jb.mul$Skewness$parameter,
       normality_test$jb.mul$Kurtosis$parameter)
pv <- c(normality_test$jb.mul$JB$p.value,
        normality_test$jb.mul$Skewness$p.value,
        normality_test$jb.mul$Kurtosis$p.value)

normality_test <- data.frame(e, p, pv)
colnames(normality_test) <- c("Estadístico", "Parámetro", "P Value")
rownames(normality_test) <- c("Jarque-Bera", "Asimetría", "Curtosis")

normality_test %>%
  kable(booktabs = T, caption = "Normalidad de los residuos", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

Todos los estadísticos brindan información para reconocer normalidad en la distribución de los errores.

#### Causalidad e Impulso Respuesta

En este punto es posible probar la causalidad de Granger.

```{r granger-bm-is}
cause_bm <- causality(is_bm_model, cause = "train_bm")
cause_is <- causality(is_bm_model, cause = "train_is")


granger <- data.frame(c(cause_bm$Granger$method, cause_is$Granger$method), 
                      c(cause_bm$Granger$p.value, cause_is$Granger$p.value))

colnames(granger) <- c("Método", "P-Value")

granger %>%
  kable(booktabs = T, caption = "Causalidad de Grange: Base Monetaria e Índice de Salarios", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7) %>%
  column_spec(2, color = ifelse(granger[,2] < 0.05, "red", "black"))

```

En la Tabla \@ref(tab:granger-bm-is) se observa evidencia que el Índice de Salarios es causa de la Base Monetaria.

Se genera la función Impulso-Respuesta para describir la respuesta de la Base Monetaria a un _shock_ en los salarios.

```{r}
irf_is <- irf(is_bm_model, 
              impulse = "train_is", 
              response = "train_bm",  
              n.ahead = 15)

irf_is_data <- data.frame(irf_is$irf$train_is[ ,1],
                          irf_is$Lower$train_is[ ,1],
                          irf_is$Upper$train_is[ ,1], 
                          0:15)
colnames(irf_is_data) <- c('irf', 'lower', 'upper', 'lags')
```

```{r irf-is-bm, fig.cap="Impulso Respuesta: Base Monetaria e Índice de Salarios", fig.height=4, fig.width=10}
irf_is_data %>%
  ggplot(aes(lags, irf)) +
  geom_line(aes(y = upper), colour = 'lightblue2') +
  geom_line(aes(y = lower), colour = 'lightblue')+
  geom_line(aes(y = irf))+
  geom_ribbon(aes(x=lags, ymax=upper, ymin=lower), fill="lightblue", alpha=.1) +
  xlab("") + ylab("Base Monetaria") + ggtitle("Impulso Respuesta: Base Monetaria e Índice de Salarios") +
  #theme(axis.text.x=element_blank()) +
  geom_line(colour = 'black')
```

Gráficamente (Figura \@ref(fig:irf-is-bm)), los _shocks_ en el Índice de Salarios tienen un impacto a mediado plazo en la Base Monetaria, sus efectos perduran aproximadamente 10 meses después de su ocurrencia.

```{r}
#accuracy

ipc_bm_model_forecast <- forecast(ipc_bm_model, h = 3)
is_bm_model_forecast <- forecast(is_bm_model, h = 3)
ipc_is_model_forecast <- forecast(ipc_is_model, h = 3)

#accuracy(test_ipc, ipc_bm_model_forecast$forecast$train_ipc$mean)
ipc_var_accuracy <- accuracy(test_ipc, ipc_is_model_forecast$forecast$train_ipc$mean)

bm_var_accuracy <- accuracy(test_bm, ipc_bm_model_forecast$forecast$train_bm$mean)
#accuracy(test_bm, is_bm_model_forecast$forecast$train_bm$mean)

is_var_accuracy <- accuracy(test_is, ipc_is_model_forecast$forecast$train_is$mean)
#accuracy(test_is, is_bm_model_forecast$forecast$train_is$mean)
```

### Pronósticos

```{r}
diff_inv <- function(dif_ts, original_ts, n_diff) {

  ts_dif_inv <-  dif_ts
  
  for (i in n_diff:1) {
    if (i > 1) {
      ts_dif_i_1 <-  diff(original_ts, lag = 1, differences = (i-1))
    } else {
      ts_dif_i_1 <- original_ts
    }
    ts_dif_inv <- diffinv(ts_dif_inv, lag = 1, differences = 1) + ts_dif_i_1[1]
  }
  
  return(ts_dif_inv)
}


join_ts <- function(before, after){
  return(ts(c(before,after), start=start(before), frequency=frequency(before)))
}


adjust_forecast <- function(dif_ts, ts, forecast_object, ts_name, ts_ndiffs){

  forecast_start = start(forecast_object$forecast[[ts_name]]$mean)
  
  forecast_object$forecast[[ts_name]]$mean = window(diff_inv(join_ts(dif_ts, forecast_object$forecast[[ts_name]]$mean), ts, ts_ndiffs), start = forecast_start)
  forecast_object$forecast[[ts_name]]$lower[, 1] = window(diff_inv(join_ts(dif_ts, forecast_object$forecast[[ts_name]]$lower[, 1]), ts, ts_ndiffs), start = forecast_start)
  forecast_object$forecast[[ts_name]]$lower[, 2] = window(diff_inv(join_ts(dif_ts, forecast_object$forecast[[ts_name]]$lower[, 2]), ts, ts_ndiffs), start = forecast_start)
  forecast_object$forecast[[ts_name]]$upper[, 1] = window(diff_inv(join_ts(dif_ts, forecast_object$forecast[[ts_name]]$upper[, 1]), ts, ts_ndiffs), start = forecast_start)
  forecast_object$forecast[[ts_name]]$upper[, 2] = window(diff_inv(join_ts(dif_ts, forecast_object$forecast[[ts_name]]$upper[, 2]), ts, ts_ndiffs), start = forecast_start)  
  
  return(forecast_object)
}

```

```{r}
# var_forecast <- forecast(ipc_bm_model, h = 6)
# 
# o_dif_ts_bm <- diff(ts_bm, lag = 1, differences = bm_ndiffs) #a la que veníamos usando le sacamos un dato para que quede del mismo tamaño que la otra
# 
# var_forecast <- adjust_forecast(dif_ts_ipc, ts_ipc, var_forecast, "dif_ts_ipc", ipc_ndiffs)
# var_forecast <- adjust_forecast(o_dif_ts_bm, ts_bm, var_forecast, "dif_ts_bm", bm_ndiffs)
```


```{r pronostico-general, fig.cap="Predicciones", fig.height=4, fig.width=10, warning=FALSE, fig.pos="H"}
# autoplot(ts_ipc, 
#          series = "Indice Precios Consumidor") +
#   autolayer(var_forecast$forecast$dif_ts_ipc,
#             series = "Pronostico Indice Precios Consumidor", 
#             alpha = 0.5) +
#     autolayer(ts_bm, 
#             series = "Base Monetaria") +
#   autolayer(var_forecast$forecast$dif_ts_bm, 
#             series = "Pronostico Base Monetaria", 
#             alpha = 0.5) +
#   labs(x = "Tiempo", y = "Porcentaje Acumulado") +
#   ggtitle("Series con sus pronosticos")
```



## Prophet

Otra forma de modelar las series analizadas anteriomente es mediante Prophet. Se modela cada una de forma independiente, separando el conjunto de datos en train y test. Se considera train hasta el 2021-04-01 y test hasta el 2021-07-01.

Una de las ventajas que posee Prophet es que puede tener en cuenta eventos como las vacaciones nacionales en el analisis de la serie. Debido a que gran parte de la economia argentina responde a situaciones politicas del momento, resulta interesante tener en cuenta los siguientes eventos:

- Elecciones PASO (2019-08-11)
- Elecciones Presidenciales (2019-10-27)
- Anuncio del aislamiento preventivo y obligatorio por COVID (2020-03-20)

Se utiliza Prophet para modelar las 3 series, teniendo en cuenta dichos eventos.

```{r}
holidays <- read.csv('eventos.csv')
```


### Índice de Precios al Consumidor

```{r include=FALSE}
ipc_model_data <- rename(ipc, ds = fecha, y = indice_precios_consumidor_acumulada)

ipc_train <- head(ipc_model_data, 53)
ipc_test <- tail(ipc_model_data, 3)

ipc_prophet_model <- prophet(ipc_train, holidays = holidays)
```

Se entrena un modelo Prophet para IPC y se analizan las metricas de performance. En la Tabla \@ref(tab:ipc-prophet-acc) se detallan las métricas de testing obtenidas. 

```{r ipc-prophet-acc}
ipc_x_test <- make_future_dataframe(ipc_prophet_model, periods = 3, freq = "month", include_history = FALSE)
ipc_y_pred <- predict(ipc_prophet_model, ipc_x_test)
ipc_prophet_accuracy <- accuracy(ipc_test$y, ipc_y_pred$yhat)

ipc_prophet_accuracy %>% 
  as_tibble() %>% 
  kable(booktabs = T, caption = "Métricas del modelo Prophet sobre IPC", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

```{r}
ipc_future <- make_future_dataframe(ipc_prophet_model, periods = 9, freq = "month")
ipc_prophet_forecast <- predict(ipc_prophet_model, ipc_future)
```

```{r fig.cap="Predicciones de IPC"}
plot(ipc_prophet_model, ipc_prophet_forecast) + 
  ggtitle("Índice de Precios al Consumidor", subtitle = "Con prediccion de 9 meses con Prophet") +
  ylab("% cambio acumulado") +
  xlab("Fecha")
```

Resulta interesante mencionar que los intervalos de confianza de las predicciones es mas acotado que el obtenido con los modelos VAR analizados anteriormente.

```{r ipc-pp-componentes fig.cap="Componentes del modelo IPC"}
prophet_plot_components(ipc_prophet_model, ipc_prophet_forecast)
```

En este caso, ambas elecciones afectaron la serie de forma positiva, aumentando entre 1,5% y 3% el Indice de Precios al consumidor. Del otro lado, el inicio del aislamiento por covid afecta la serie disminiyendo un 1%.

Entre fin de agosto e inicios de septiembre la serie presenta una estacionalidad positiva, lo que provoca un aumento mayor que los meses anteriores. A finales de octubre este comportamiento se revierte.

### Índice de Salarios

```{r include=FALSE}
is_model_data <- rename(is, ds = fecha, y = indice_salarios_acumulada)

is_train <- head(is_model_data, 53)
is_test <- tail(is_model_data, 3)

is_prophet_model <- prophet(is_train, holidays = holidays)
```


```{r}
is_x_test <- make_future_dataframe(is_prophet_model, periods = 3, freq = "month", include_history = FALSE)
is_y_pred <- predict(is_prophet_model, is_x_test)
is_prophet_accuracy <- accuracy(is_test$y, is_y_pred$yhat)

is_prophet_accuracy %>% 
  as_tibble() %>% 
  kable(booktabs = T, caption = "Métricas de performance", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

```{r}
is_future <- make_future_dataframe(is_prophet_model, periods = 9, freq = "month")
is_prophet_forecast <- predict(is_prophet_model, is_future)
```

```{r}
plot(is_prophet_model, is_prophet_forecast) + 
  ggtitle("Índice de Salarios", subtitle = "Con prediccion de 9 meses") +
  ylab("% cambio acumulado") +
  xlab("Fecha")
```

```{r}
prophet_plot_components(is_prophet_model, is_prophet_forecast)
```

### Base Monetaria

```{r include=FALSE}
bm_model_data <- rename(bm, ds = fecha, y = variacion_base_monetaria_acumulada)

bm_train <- head(bm_model_data, 53)
bm_test <- tail(bm_model_data, 3)

bm_prophet_model <- prophet(bm_train, holidays = holidays)
```

```{r}
bm_x_test <- make_future_dataframe(bm_prophet_model, periods = 3, freq = "month", include_history = FALSE)
bm_y_pred <- predict(bm_prophet_model, bm_x_test)
bm_prophet_accuracy <- accuracy(bm_test$y, bm_y_pred$yhat)

bm_prophet_accuracy %>% 
  as_tibble() %>% 
  kable(booktabs = T, caption = "Métricas de performance", digits = 3) %>%
  kable_styling(latex_options = c("striped", "hold_position"), font_size = 7)
```

```{r}
bm_future <- make_future_dataframe(bm_prophet_model, periods = 9, freq = "month")
bm_prophet_forecast <- predict(bm_prophet_model, bm_future)
```

```{r}
plot(bm_prophet_model, bm_prophet_forecast) + 
  ggtitle("Base monetaria", subtitle = "Con prediccion de 9 meses") +
  ylab("% cambio acumulado") +
  xlab("Fecha")
```

```{r}
prophet_plot_components(bm_prophet_model, bm_prophet_forecast)
```





\newpage

# Conclusiones

TODO: ALGO

\newpage

# Referencias bibliográficas

<div id="refs"></div>

\newpage

# Apéndices

## Modelo $VAR$ para IPC y Base Monetaria {#ipc-bm-modelo-var}

```{r}
summary(ipc_bm_model)
```

## Modelo $VAR$ para IPC e Índice de Salarios {#ipc-is-modelo-var}

```{r}
summary(ipc_is_model)
```

## Modelo $VAR$ para Índice de Salarios y Base Monetaria {#is-bm-modelo-var}

```{r}
summary(is_bm_model)
```



